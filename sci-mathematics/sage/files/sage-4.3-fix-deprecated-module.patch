--- src/lib/sqlalchemy/orm/attributes.py.orig	2010-01-08 20:15:21.235103232 +0000
+++ src/lib/sqlalchemy/orm/attributes.py	2010-01-08 20:15:39.765102887 +0000
@@ -720,8 +720,7 @@
         self.attrs = {}
         self.has_mutable_scalars = False
 
-import sets
-_empty_set = sets.ImmutableSet()
+_empty_set = frozenset
 
 class InstanceState(object):
     """tracks state information at the instance level."""
--- src/lib/sqlalchemy/orm/collections.py.orig	2010-01-08 20:09:24.354101961 +0000
+++ src/lib/sqlalchemy/orm/collections.py	2010-01-08 20:11:28.806102439 +0000
@@ -97,7 +97,6 @@
 
 import copy
 import inspect
-import sets
 import sys
 import weakref
 
@@ -1141,10 +1140,7 @@
     return l
 
 
-try:
-    _set_binop_bases = (set, frozenset, sets.BaseSet)
-except NameError:
-    _set_binop_bases = (sets.BaseSet,)
+_set_binop_bases = (set, frozenset)
 
 def _set_binops_check_strict(self, obj):
     """Allow only set, frozenset and self.__class__-derived objects in binops."""
--- src/lib/sqlalchemy/util.py.orig	2010-01-08 10:18:58.801450610 +0000
+++ src/lib/sqlalchemy/util.py	2010-01-08 10:20:20.290449516 +0000
@@ -4,7 +4,7 @@
 # This module is part of SQLAlchemy and is released under
 # the MIT License: http://www.opensource.org/licenses/mit-license.php
 
-import inspect, itertools, new, operator, sets, sys, warnings, weakref
+import inspect, itertools, new, operator, sys, warnings, weakref
 import __builtin__
 types = __import__('types')
 
@@ -16,53 +16,8 @@
     import dummy_thread as thread
     import dummy_threading as threading
 
-try:
-    Set = set
-    set_types = set, sets.Set
-except NameError:
-    set_types = sets.Set,
-    # layer some of __builtin__.set's binop behavior onto sets.Set
-    class Set(sets.Set):
-        def _binary_sanity_check(self, other):
-            pass
-
-        def issubset(self, iterable):
-            other = type(self)(iterable)
-            return sets.Set.issubset(self, other)
-        def __le__(self, other):
-            sets.Set._binary_sanity_check(self, other)
-            return sets.Set.__le__(self, other)
-        def issuperset(self, iterable):
-            other = type(self)(iterable)
-            return sets.Set.issuperset(self, other)
-        def __ge__(self, other):
-            sets.Set._binary_sanity_check(self, other)
-            return sets.Set.__ge__(self, other)
-
-        # lt and gt still require a BaseSet
-        def __lt__(self, other):
-            sets.Set._binary_sanity_check(self, other)
-            return sets.Set.__lt__(self, other)
-        def __gt__(self, other):
-            sets.Set._binary_sanity_check(self, other)
-            return sets.Set.__gt__(self, other)
-
-        def __ior__(self, other):
-            if not isinstance(other, sets.BaseSet):
-                return NotImplemented
-            return sets.Set.__ior__(self, other)
-        def __iand__(self, other):
-            if not isinstance(other, sets.BaseSet):
-                return NotImplemented
-            return sets.Set.__iand__(self, other)
-        def __ixor__(self, other):
-            if not isinstance(other, sets.BaseSet):
-                return NotImplemented
-            return sets.Set.__ixor__(self, other)
-        def __isub__(self, other):
-            if not isinstance(other, sets.BaseSet):
-                return NotImplemented
-            return sets.Set.__isub__(self, other)
+Set = set
+set_types = set
 
 try:
     import cPickle as pickle
