--- src/networkx/hybrid.py.orig	2010-01-16 12:24:45.121690803 +0000
+++ src/networkx/hybrid.py	2010-01-16 12:26:14.111691147 +0000
@@ -13,7 +13,6 @@
 #    Distributed under the terms of the GNU Lesser General Public License
 #    http://www.gnu.org/copyleft/lesser.html
 import copy
-import sets
 from networkx.path import shortest_path
 
 def kl_connected_subgraph(G,k,l,low_memory=False,same_as_graph=False):
@@ -38,7 +37,7 @@
             (u,v)=edge
             ### Get copy of graph needed for this search
             if low_memory:
-                verts=sets.Set([u,v])
+                verts=set([u,v])
                 for i in range(k):
                     [verts.update(G.neighbors(w)) for w in verts.copy()]
                 G2=G.subgraph(list(verts))
@@ -78,7 +77,7 @@
         (u,v)=edge
         ### Get copy of graph needed for this search
         if low_memory:
-            verts=sets.Set([u,v])
+            verts=set([u,v])
             for i in range(k):
                 [verts.update(G.neighbors(w)) for w in verts.copy()]
             G2=G.subgraph(list(verts))
--- src/networkx/isomorphvf2.py.orig	2010-01-16 12:19:01.582690229 +0000
+++ src/networkx/isomorphvf2.py	2010-01-16 12:20:25.081690945 +0000
@@ -26,7 +26,6 @@
 # UC Davis.
 
 import sys
-from sets import Set
 
 class GraphMatcher(object):
     """A GraphMatcher is responsible for matching undirected graphs (Graph or
@@ -108,7 +107,7 @@
             # P(s) = (N_1 - M_1) x {min (N_2 - M_2)}
             if not (T1_inout or T2_inout):
                 # First we determine the candidate node for G2
-                other_node = min(Set(self.G2.nodes()) - Set(GMState.core_2))
+                other_node = min(set(self.G2.nodes()) - set(GMState.core_2))
                 for node in self.G1:
                     if node not in GMState.core_1:
                         yield node, other_node
@@ -422,7 +421,7 @@
                     # P(s) = (N_1 - M_1) x {min (N_2 - M_2)}
                     if not (T1_out or T2_out or T1_in or T2_in):
                         # First we determine the candidate node for G2
-                        node_2 = min(Set(self.G2.nodes()) - Set(DiGMState.core_2))
+                        node_2 = min(set(self.G2.nodes()) - set(DiGMState.core_2))
                         for node_1 in self.G1:
                             if node_1 not in DiGMState.core_1:
                                 yield node_1, node_2
@@ -818,7 +817,7 @@
             # Now we add every other node...
             
             # Updates for T_1^{inout}
-            new_nodes = Set([])
+            new_nodes = set([])
             for node in GMState.core_1:
                 new_nodes.update([neighbor for neighbor in GM.G1.neighbors(node) if neighbor not in GMState.core_1])
             for node in new_nodes:
@@ -826,7 +825,7 @@
                     GMState.inout_1[node] = self.depth
 
             # Updates for T_2^{inout}
-            new_nodes = Set([])
+            new_nodes = set([])
             for node in GMState.core_2:
                 new_nodes.update([neighbor for neighbor in GM.G2.neighbors(node) if neighbor not in GMState.core_2])
             for node in new_nodes:
@@ -923,7 +922,7 @@
             # Now we add every other node...
             
             # Updates for T_1^{in}
-            new_nodes = Set([])
+            new_nodes = set([])
             for node in DiGMState.core_1:
                 new_nodes.update([predecessor for predecessor in DiGM.G1.predecessors(node) if predecessor not in DiGMState.core_1])
             for node in new_nodes:
@@ -931,7 +930,7 @@
                     DiGMState.in_1[node] = self.depth
                 
             # Updates for T_2^{in}
-            new_nodes = Set([])
+            new_nodes = set([])
             for node in DiGMState.core_2:
                 new_nodes.update([predecessor for predecessor in DiGM.G2.predecessors(node) if predecessor not in DiGMState.core_2])
             for node in new_nodes:
@@ -939,7 +938,7 @@
                     DiGMState.in_2[node] = self.depth
                 
             # Updates for T_1^{out}
-            new_nodes = Set([])        
+            new_nodes = set([])
             for node in DiGMState.core_1:
                 new_nodes.update([successor for successor in DiGM.G1.successors(node) if successor not in DiGMState.core_1])
             for node in new_nodes:
@@ -947,7 +946,7 @@
                     DiGMState.out_1[node] = self.depth
     
             # Updates for T_2^{out}
-            new_nodes = Set([])        
+            new_nodes = set([])
             for node in DiGMState.core_2:
                 new_nodes.update([successor for successor in DiGM.G2.successors(node) if successor not in DiGMState.core_2])
             for node in new_nodes:
