--- sage/libs/ecl.pyx.orig	2011-02-15 13:53:19.869401019 +1300
+++ sage/libs/ecl.pyx	2011-02-15 13:58:53.591401003 +1300
@@ -87,27 +87,27 @@
 cdef cl_object read_from_string_clobj  #our own error catching reader
 
 cdef bint ecl_has_booted = 0
-    
+
 def init_ecl():
     r"""
     Internal function to initialize ecl. Do not call.
-    
+
     This function initializes the ECL library for use within Python.
     This routine should only be called once and importing the ecl library
     interface already does that, so do not call this yourself.
-    
+
     EXAMPLES::
-    
+
         sage: from sage.libs.ecl import *
-  
+
     At this point, init_ecl() has run. Explicitly executing it
     gives an error::
-    
+
         sage: init_ecl()
         Traceback (most recent call last):
         ...
         RuntimeError: ECL is already initialized
-  
+
     """
     global list_of_objects
     global safe_eval_clobj
@@ -127,18 +127,18 @@
 
     #we need a dummy argv for cl_boot (we just don't give any parameters)
     argv[0]=""
-    
+
     #get all the signal handlers (does any system have signal numbers above 32?)
     for i in range(1,33):
-        sigaction(i,NULL,&(act[i])) 
- 
+        sigaction(i,NULL,&(act[i]))
+
     #initialize ECL
     cl_boot(0, argv)
-    
+
     #and put the signal handlers back
     for i in range(1,33):
         sigaction(i,&(act[i]),NULL)
-    
+
     #initialise list of objects and bind to global variable
     # *SAGE-LIST-OF-OBJECTS* to make it rooted in the reachable tree for the GC
     list_of_objects=cl_cons(Cnil,cl_cons(Cnil,Cnil))
@@ -208,17 +208,17 @@
     o = ecl_cstring_to_base_string_or_nil(s)
     o = ecl_safe_funcall(read_from_string_clobj,o)
     return o
-    
+
 def shutdown_ecl():
     r"""
     Shut down ecl. Do not call.
-    
+
     Given the way that ECL is used from python, it is very difficult to ensure
     that no ECL objects exist at a particular time. Hence, destroying ECL is a
     risky proposition.
-    
+
     EXAMPLE::
-    
+
         sage: from sage.libs.ecl import *
         sage: shutdown_ecl()
     """
@@ -229,14 +229,14 @@
 def print_objects():
     r"""
     Print GC-protection list
-    
+
     Diagnostic function. ECL objects that are bound to Python objects need to
     be protected from being garbage collected. We do this by including them
     in a doubly linked list bound to the global ECL symbol
     *SAGE-LIST-OF-OBJECTS*. Only non-immediate values get included, so
     small integers do not get linked in. This routine prints the values
     currently stored.
-    
+
     EXAMPLE::
 
         sage: from sage.libs.ecl import *
@@ -248,7 +248,7 @@
         WORLD
         HELLO
     """
-    
+
     cdef cl_object c
     c = list_of_objects
     while True:
@@ -266,7 +266,7 @@
 
     cdef bytes s
     cdef cl_object L, ptr
-    
+
     if isinstance(pyobj,bool):
         if pyobj:
             return Ct
@@ -376,70 +376,81 @@
 cdef class EclObject:
     r"""
     Python wrapper of ECL objects
-    
+
     The ``EclObject`` forms a wrapper around ECL objects. The wrapper ensures
     that the data structure pointed to is protected from garbage collection in
     ECL by installing a pointer to it from a global data structure within the
     scope of the ECL garbage collector. This pointer is destroyed upon
     destruction of the EclObject.
-    
+
     EclObject() takes a Python object and tries to find a representation of it
     in Lisp.
-    
+
     EXAMPLES:
-    
+
     Python lists get mapped to LISP lists. None and Boolean values to
     appropriate values in LISP::
-    
+
         sage: from sage.libs.ecl import *
         sage: EclObject([None,true,false])
         <ECL: (NIL T NIL)>
-        
+
     Numerical values are translated to the appropriate type in LISP::
-    
+
         sage: EclObject(1)
         <ECL: 1>
         sage: EclObject(10**40)
         <ECL: 10000000000000000000000000000000000000000>
-        sage: EclObject(float(10**40))
+
+    Floats in Python are IEEE double, which LISP has as well. However,
+    the printing of floating point types in LISP depends on settings::
+
+        sage: a = EclObject(float(10**40))
+        sage: ecl_eval("(setf *read-default-float-format* 'single-float)")
+        <ECL: SINGLE-FLOAT>
+        sage: a
         <ECL: 9.999999999999999d39>
-        
+        sage: ecl_eval("(setf *read-default-float-format* 'double-float)")
+        <ECL: DOUBLE-FLOAT>
+        sage: a
+        <ECL: 9.999999999999999E39>
+
     Tuples are translated to dotted lists::
-    
+
         sage: EclObject( (false, true))
         <ECL: (NIL . T)>
-        
+
     Strings are fed to the reader, so a string normally results in a symbol::
-    
+
         sage: EclObject("Symbol")
         <ECL: SYMBOL>
-        
+
     But with proper quotation one can construct a lisp string object too::
-    
+
         sage: EclObject('"Symbol"')
         <ECL: "Symbol">
-        
+
     EclObjects translate to themselves, so one can mix::
-    
+
         sage: EclObject([1,2,EclObject([3])])
         <ECL: (1 2 (3))>
-    
+
     Calling an EclObject translates into the appropriate LISP ``apply'',
     where the argument is transformed into an EclObject itself, so one can
     flexibly apply LISP functions::
-    
+
         sage: car=EclObject("car")
         sage: cdr=EclObject("cdr")
         sage: car(cdr([1,2,3]))
         <ECL: 2>
-        
+
     and even construct and evaluate arbitrary S-expressions::
-    
+
         sage: eval=EclObject("eval")
         sage: quote=EclObject("quote")
         sage: eval([car, [cdr, [quote,[1,2,3]]]])
         <ECL: 2>
-        
+
     """
     cdef cl_object obj   #the wrapped object
     cdef cl_object node  #linked list pointer: car(node) == obj
@@ -471,12 +482,12 @@
     def __reduce__(self):
         r"""
         This is used for pickling. Not implemented
-        
+
         Ecl does not natively support serialization of its objects, so the
         python wrapper class EclObject does not support pickling. There are
         independent efforts for developing serialization for Common Lisp, such as
         CL-STORE. Look at those if you need serialization of ECL objects.
-        
+
         EXAMPLES::
 
             sage: from sage.libs.ecl import *
@@ -488,7 +499,7 @@
             sage: s==loads(dumps(s))
             Traceback (most recent call last):
             ...
-            NotImplementedError: EclObjects do not have a pickling method        
+            NotImplementedError: EclObjects do not have a pickling method
         """
         raise NotImplementedError, "EclObjects do not have a pickling method"
 
@@ -522,7 +533,7 @@
         """
         if self.node:
             remove_node(self.node)
-        
+
     def __repr__(self):
         r"""
         Produce a string representation suitable for interactive printing.
@@ -539,7 +550,7 @@
 
         """
         return "<ECL: "+str(self)+">"
-        
+
     def __str__(self):
         r"""
         Produce a string representation.
@@ -642,7 +653,7 @@
         #we could dispatch based on type here, but that seems
         #inappropriate for an *interface*.
         raise NotImplementedError,"EclObjects can only be compared for equality"
- 
+
         #if not(isinstance(left,EclObject)) or not(isinstance(right,EclObject)):
         #    raise TypeError,"Can only compare EclObjects"
         #if op == 0: # "<"
@@ -656,6 +667,44 @@
         #else:
         #    raise ValueError,"richcmp received operation code %d"%op
 
+    def __iter__(self):
+        r"""
+        Implements the iterator protocol for EclObject.
+
+        EclObject implements the iterator protocol for lists. This means
+        one can use an EclObject in the context where an iterator is
+        expected (for instance, in a list comprehension or in a for loop).
+        The iterator produces EclObjects wrapping the members of the list that
+        the original EclObject wraps.
+
+        The wrappers returned are all newly constructed but refer to the
+        original members of the list iterated over. This is usually what is
+        intended but, just as in Python, can cause surprises if the original
+        object is changed between calls to the iterator.
+
+        Since EclObject translates Python Lists into LISP lists and Python
+        tuples into LISP "dotted" lists (lists for which the final CDR is not
+        necessarily NIL), and both these python structures are iterable, the
+        corresponding EclObjects are iterable as well.
+
+        EclObjects that are not lists are not iterable.
+
+        EXAMPLES::
+            sage: from sage.libs.ecl import *
+            sage: [i for i in EclObject("(1 2 3)")]
+            [<ECL: 1>, <ECL: 2>, <ECL: 3>]
+            sage: [i for i in EclObject("(1 2 . 3)")]
+            [<ECL: 1>, <ECL: 2>, <ECL: 3>]
+            sage: [i for i in EclObject("NIL")]
+            []
+            sage: [i for i in EclObject("T")]
+            Traceback (most recent call last):
+            ...
+            TypeError: ECL object is not iterable
+
+        """
+        return EclListIterator(self)
+
     def eval(self):
         r"""
         Evaluate object as an S-Expression
@@ -710,8 +759,8 @@
         if not(bint_consp(self.obj)):
             raise TypeError,"rplaca can only be applied to a cons"
         cl_rplaca(self.obj, d.obj)
-        
-        
+
+
     def rplacd(self,EclObject d):
         r"""
         Destructively replace cdr(self) with d.
@@ -751,7 +800,7 @@
             sage: L.cdar()
             <ECL: (2)>
             sage: L.cddr()
-            <ECL: NIL>   
+            <ECL: NIL>
         """
         if not(bint_consp(self.obj)):
             raise TypeError,"car can only be applied to a cons"
@@ -776,7 +825,7 @@
             sage: L.cdar()
             <ECL: (2)>
             sage: L.cddr()
-            <ECL: NIL>   
+            <ECL: NIL>
         """
         if not(bint_consp(self.obj)):
             raise TypeError,"cdr can only be applied to a cons"
@@ -801,7 +850,7 @@
             sage: L.cdar()
             <ECL: (2)>
             sage: L.cddr()
-            <ECL: NIL>   
+            <ECL: NIL>
         """
         if not(bint_consp(self.obj) and bint_consp(cl_car(self.obj))):
             raise TypeError,"caar can only be applied to a cons"
@@ -826,7 +875,7 @@
             sage: L.cdar()
             <ECL: (2)>
             sage: L.cddr()
-            <ECL: NIL>   
+            <ECL: NIL>
         """
         if not(bint_consp(self.obj) and bint_consp(cl_cdr(self.obj))):
             raise TypeError,"cadr can only be applied to a cons"
@@ -851,7 +900,7 @@
             sage: L.cdar()
             <ECL: (2)>
             sage: L.cddr()
-            <ECL: NIL>   
+            <ECL: NIL>
         """
         if not(bint_consp(self.obj) and bint_consp(cl_car(self.obj))):
             raise TypeError,"cdar can only be applied to a cons"
@@ -876,11 +925,11 @@
             sage: L.cdar()
             <ECL: (2)>
             sage: L.cddr()
-            <ECL: NIL>   
+            <ECL: NIL>
         """
         if not(bint_consp(self.obj) and bint_consp(cl_cdr(self.obj))):
             raise TypeError,"cddr can only be applied to a cons"
-        return ecl_wrap(cl_cddr(self.obj))        
+        return ecl_wrap(cl_cddr(self.obj))
 
     def fixnump(self):
         r"""
@@ -925,7 +974,7 @@
             False
         """
         return bint_nullp(self.obj)
-    
+
     def listp(self):
         r"""
         Return True if self is a list, False otherwise. NIL is a list.
@@ -939,7 +988,7 @@
             True
         """
         return bint_listp(self.obj)
-    
+
     def consp(self):
         r"""
         Return True if self is a cons, False otherwise. NIL is not a cons.
@@ -953,7 +1002,7 @@
             True
         """
         return bint_consp(self.obj)
-        
+
     def atomp(self):
         r"""
         Return True if self is atomic, False otherwise.
@@ -984,6 +1033,96 @@
         """
         return bint_symbolp(self.obj)
 
+cdef class EclListIterator:
+    r"""
+    Iterator object for an ECL list
+
+    This class is used to implement the iterator protocol for EclObject.
+    Do not instantiate this class directly but use the iterator method
+    on an EclObject instead. It is an error if the EclObject is not a list.
+
+    EXAMPLES::
+
+        sage: from sage.libs.ecl import *
+        sage: I=EclListIterator(EclObject("(1 2 3)"))
+        sage: type(I)
+        <type 'sage.libs.ecl.EclListIterator'>
+        sage: [i for i in I]
+        [<ECL: 1>, <ECL: 2>, <ECL: 3>]
+        sage: [i for i in EclObject("(1 2 3)")]
+        [<ECL: 1>, <ECL: 2>, <ECL: 3>]
+        sage: EclListIterator(EclObject("1"))
+        Traceback (most recent call last):
+        ...
+        TypeError: ECL object is not iterable
+
+    """
+    cdef EclObject current
+
+    def __init__(EclListIterator self, EclObject o):
+        r"""
+        Initialize EclListIterator
+
+        EXAMPLES::
+
+            sage: from sage.libs.ecl import *
+            sage: I=EclListIterator(EclObject("(1 2 3)"))
+            sage: type(I)
+            <type 'sage.libs.ecl.EclListIterator'>
+
+        """
+        if not o.listp():
+            raise TypeError,"ECL object is not iterable"
+        self.current = ecl_wrap(o.obj)
+
+    def __iter__(EclListIterator self):
+        r"""
+        Return self
+
+        It seems standard that iterators return themselves if asked to produce
+        an iterator.
+
+        EXAMPLES::
+
+            sage: from sage.libs.ecl import *
+            sage: I=EclListIterator(EclObject("(1 2 3)"))
+            sage: id(I) == id(I.__iter__())
+            True
+
+        """
+        return self
+
+    def __next__(EclListIterator self):
+        r"""
+        Get next element from iterator
+
+        EXAMPLES::
+
+            sage: from sage.libs.ecl import *
+            sage: I=EclListIterator(EclObject("(1 2 3)"))
+            sage: I.next()
+            <ECL: 1>
+            sage: I.next()
+            <ECL: 2>
+            sage: I.next()
+            <ECL: 3>
+            sage: I.next()
+            Traceback (most recent call last):
+            ...
+            StopIteration
+
+        """
+
+        if self.current.nullp():
+            raise StopIteration
+        elif self.current.consp():
+            r = self.current.car()
+            self.current = self.current.cdr()
+        else:
+            r = self.current
+            self.current = ecl_wrap(Cnil)
+        return r
+
 #input: a cl-object. Output: EclObject wrapping that.
 cdef EclObject ecl_wrap(cl_object o):
     cdef EclObject obj = EclObject.__new__(EclObject)
@@ -994,7 +1133,7 @@
 cpdef EclObject ecl_eval(bytes s):
     """
     Read and evaluate string in Lisp and return the result
-    
+
     EXAMPLES::
 
         sage: from sage.libs.ecl import *
