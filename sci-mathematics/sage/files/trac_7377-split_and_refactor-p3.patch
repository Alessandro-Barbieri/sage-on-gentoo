# HG changeset patch
# User Jean-Pierre Flori <flori@enst.fr>
# Date 1297688775 -3600
# Node ID e20fb42bdea9d561c0cf259562ab74f529fbb8f6
# Parent  df3ffca8158810ee8dc20ab1476ebfc7ba04c323
Split Expect interface.

diff -r df3ffca81588 -r e20fb42bdea9 sage/calculus/calculus.py
--- a/sage/calculus/calculus.py	Tue Feb 15 17:14:05 2011 +0100
+++ b/sage/calculus/calculus.py	Mon Feb 14 14:06:15 2011 +0100
@@ -364,7 +364,6 @@
 from sage.rings.real_mpfr import create_RealNumber
 
 from sage.misc.latex import latex, latex_variable_name
-from sage.interfaces.maxima import Maxima
 from sage.misc.parser import Parser
 
 from sage.symbolic.ring import var, SR, is_SymbolicVariable
@@ -374,20 +373,22 @@
 from sage.symbolic.integration.integral import indefinite_integral, \
         definite_integral
 import sage.symbolic.pynac
-import sage.interfaces.maxima_lib
 
 """
 Check if maxima has redundant variables defined after initialization #9538::
 
-    sage: maxima = sage.interfaces.maxima_lib.maxima
+    sage: maxima = sage.interfaces.maxima.maxima
     sage: maxima('f1')
     f1
     sage: sage.calculus.calculus.maxima('f1')
     f1
 """
-maxima = sage.interfaces.maxima_lib.maxima
-#maxima = Maxima(init_code = ['display2d:false', 'domain: complex',
-#                             'keepfloat: true', 'load(to_poly_solver)', 'load(simplify_sum)'],
+import sage.interfaces.maxima_lib
+maxima = sage.interfaces.maxima_lib.maxima_lib
+# This is not the same instance of Maxima as the general purpose one
+#from sage.interfaces.maxima import Maxima
+#maxima = Maxima(init_code = ['display2d : false', 'domain : complex',
+#                             'keepfloat : true', 'load(to_poly_solver)', 'load(simplify_sum)'],
 #                script_subdirectory=None)
 
 ########################################################
diff -r df3ffca81588 -r e20fb42bdea9 sage/interfaces/all.py
--- a/sage/interfaces/all.py	Tue Feb 15 17:14:05 2011 +0100
+++ b/sage/interfaces/all.py	Mon Feb 14 14:06:15 2011 +0100
@@ -17,7 +17,10 @@
 from magma_free import magma_free
 from macaulay2 import macaulay2, macaulay2_console, Macaulay2
 from maple import maple, maple_console, Maple
-from maxima import maxima, maxima_console, is_MaximaElement, Maxima
+from maxima_abstract import maxima_console
+from maxima import maxima, is_MaximaElement, Maxima
+# import problems
+#from maxima_lib import maxima_lib
 from mathematica import mathematica, mathematica_console, Mathematica
 from matlab import matlab, matlab_console, matlab_version, Matlab
 from mupad import mupad, mupad_console, Mupad  # NOT functional yet
diff -r df3ffca81588 -r e20fb42bdea9 sage/interfaces/expect.py
--- a/sage/interfaces/expect.py	Tue Feb 15 17:14:05 2011 +0100
+++ b/sage/interfaces/expect.py	Mon Feb 14 14:06:15 2011 +0100
@@ -1,5 +1,5 @@
 """
-Common Interface Functionality
+Common Interface Functionality through Pexpect
 
 See the examples in the other sections for how to use specific
 interfaces. The interface classes all derive from the generic
@@ -17,6 +17,8 @@
 - Simon King (2010-09-25): Expect._local_tmpfile() depends on
   Expect.pid() and is cached; Expect.quit() clears that cache,
   which is important for forking.
+
+- Jean-Pierre Flori (2010,2011): Split non Pexpect stuff into a parent class.
 """
 
 #*****************************************************************************
@@ -42,6 +44,8 @@
 import time
 import gc
 import operator
+import quit
+import cleaner
 from random import randrange
 
 ########################################################
@@ -51,23 +55,14 @@
 ########################################################
 import pexpect
 from pexpect import ExceptionPexpect
-
+from sage.interfaces.interface import Interface, InterfaceElement, InterfaceFunction, InterfaceFunctionElement, AsciiArtString
 
 from sage.structure.sage_object import SageObject
 from sage.structure.parent_base import ParentWithBase
-import  sage.structure.element
+from sage.structure.element import RingElement
 
 import sage.misc.sage_eval
-
-import quit
-
-import cleaner
-
-import os
-
 from sage.misc.misc import SAGE_ROOT, verbose, SAGE_TMP_INTERFACE, LOCAL_IDENTIFIER
-from sage.structure.element import RingElement
-
 from sage.misc.object_multiplexer import Multiplex
 
 BAD_SESSION = -2
@@ -142,15 +137,7 @@
             gc.enable()
         return False
 
-class AsciiArtString(str):
-    def __repr__(self):
-        return str(self)
-
-class PropTypeError(Exception):
-    pass
-    
-
-class Expect(ParentWithBase):
+class Expect(Interface):
     """
     Expect interface object.
     """
@@ -161,6 +148,7 @@
                  logfile = None, eval_using_file_cutoff=0,
                  do_cleaner = True, remote_cleaner = False, path=None):
 
+        Interface.__init__(self, name)
         self.__is_remote = False
         self.__remote_cleaner = remote_cleaner
         if command == None:
@@ -188,8 +176,6 @@
         self.__maxread = maxread
         self._eval_using_file_cutoff = eval_using_file_cutoff
         self.__script_subdirectory = script_subdirectory
-        self.__name = name
-        self.__coerce_name = '_' + name.lower() + '_'
         self.__command = command
         self._prompt = prompt
         self._restart_on_ctrlc = restart_on_ctrlc
@@ -199,7 +185,7 @@
         elif script_subdirectory is None:
             self.__path = '.'
         else:
-            self.__path = '%s/data/extcode/%s/%s'%(SAGE_ROOT,self.__name,
+            self.__path = '%s/data/extcode/%s/%s'%(SAGE_ROOT,name,
                                                    self.__script_subdirectory)
         self.__initialized = False
         self.__seq = -1
@@ -212,11 +198,9 @@
         if isinstance(logfile, basestring):
             logfile = open(logfile,'w')
         self.__logfile = logfile
-
         
         quit.expect_objects.append(weakref.ref(self))
         self._available_vars = []
-        ParentWithBase.__init__(self, self)
 
     def _get(self, wait=0.1, alternate_prompt=None):
         if self._expect is None:
@@ -286,9 +270,6 @@
     def user_dir(self):
         return self.__path
 
-    def _repr_(self):
-        return self.__name.capitalize()
-
     def _change_prompt(self, prompt):
         self._prompt = prompt
 
@@ -299,9 +280,6 @@
 #            os.makedirs(T)
 #        return T + str(x)
 
-    def name(self, new_name=None):
-        return self.__name
-
     def path(self):
         return self.__path
 
@@ -461,9 +439,9 @@
         except (ExceptionPexpect, pexpect.EOF, IndexError):
             self._expect = None
             self._session_number = BAD_SESSION
-            failed_to_start.append(self.__name)
+            failed_to_start.append(self.name())
             raise RuntimeError, "Unable to start %s because the command '%s' failed.\n%s"%(
-                self.__name, cmd, self._install_hints())
+                self.name(), cmd, self._install_hints())
 
         os.chdir(current_path)
         self._expect.timeout = self.__max_startup_time
@@ -476,8 +454,8 @@
         except (pexpect.TIMEOUT, pexpect.EOF), msg:
             self._expect = None
             self._session_number = BAD_SESSION
-            failed_to_start.append(self.__name)
-            raise RuntimeError, "Unable to start %s"%self.__name
+            failed_to_start.append(self.name())
+            raise RuntimeError, "Unable to start %s"%self.name()
         self._expect.timeout = None
         with gc_disabled():
             if block_during_init:
@@ -513,12 +491,6 @@
         except Exception, msg:
             pass
 
-    def cputime(self):
-        """
-        CPU time since this process started running.
-        """
-        raise NotImplementedError
-
     def quit(self, verbose=False, timeout=0.25):
         """
         EXAMPLES::
@@ -1056,185 +1028,6 @@
         except TypeError, s:
             raise TypeError, 'error evaluating "%s":\n%s'%(code,s)
 
-    def execute(self, *args, **kwds):
-        return self.eval(*args, **kwds)
-
-    def __call__(self, x, name=None):
-
-        r"""
-        Create a new object in self from x.
-
-        The object X returned can be used like any Sage object, and
-        wraps an object in self.  The standard arithmetic operators
-        work.  Moreover if foo is a function then
-                      X.foo(y,z,...)
-        calls foo(X, y, z, ...) and returns the corresponding object.
-
-        EXAMPLES::
-        
-            sage: gp(2)
-            2
-            sage: gp('2')
-            2
-            sage: a = gp(2); gp(a) is a
-            True
-
-        """
-        cls = self._object_class()
-
-        #Handle the case when x is an object
-        #in some interface.
-        if isinstance(x, ExpectElement):
-            if x.parent() is self:
-                return x
-
-            #We convert x into an object in this
-            #interface by first going through Sage.
-            try:
-                return self(x._sage_())
-            except (NotImplementedError, TypeError):
-                pass
-            
-        if isinstance(x, basestring):
-            return cls(self, x, name=name)
-        try:
-            return self._coerce_from_special_method(x)
-        except TypeError:
-            raise
-        except AttributeError, msg:
-            pass
-        try:
-            return self._coerce_impl(x, use_special=False)
-        except TypeError, msg:
-            try:
-                return cls(self, str(x), name=name)
-            except TypeError, msg2:
-                raise TypeError, msg
-
-    def _coerce_from_special_method(self, x):
-        """
-        Tries to coerce to self by calling a special underscore method.
-        
-        If no such method is defined, raises an AttributeError instead of a
-        TypeError.
-        """
-        s = '_%s_'%self.name()
-        if s == '_pari_':
-            s = '_gp_'
-        try:
-            return (x.__getattribute__(s))(self)
-        except AttributeError:
-            return self(x._interface_init_())
-            
-    def _coerce_impl(self, x, use_special=True):
-        if isinstance(x, (int, long)):
-            import sage.rings.all
-            return self(sage.rings.all.Integer(x))
-        elif isinstance(x, float):
-            import sage.rings.all
-            return self(sage.rings.all.RDF(x))
-        if use_special:
-            try:
-                return self._coerce_from_special_method(x)
-            except AttributeError, msg:
-                pass
-            
-        if isinstance(x, (list, tuple)):
-            A = []
-            z = []
-            cls = self._object_class()
-            for v in x:
-                if isinstance(v, cls):
-                    A.append(v.name())
-                    z.append(v)
-                else:
-                    w = self(v)
-                    A.append(w.name())
-                    z.append(w)
-            X = ','.join(A)
-            r = self.new('%s%s%s'%(self._left_list_delim(), X, self._right_list_delim()))
-            r.__sage_list = z   # do this to avoid having the entries of the list be garbage collected
-            return r
-
-
-        raise TypeError, "unable to coerce element into %s"%self.name()
-
-    def new(self, code):
-        return self(code)
-
-    ###################################################################
-    # these should all be appropriately overloaded by the derived class
-    ###################################################################
-    
-    def _left_list_delim(self):
-        return "["
-    
-    def _right_list_delim(self):
-        return "]"
-    
-    def _left_func_delim(self):
-        return "("
-    
-    def _right_func_delim(self):
-        return ")"
-    
-    def _assign_symbol(self):
-        return "="
-    
-    def _equality_symbol(self):
-        raise NotImplementedError
-
-    # For efficiency purposes, you should definitely override these
-    # in your derived class.
-    def _true_symbol(self):
-        try:
-            return self.__true_symbol
-        except AttributeError:
-            self.__true_symbol = self.eval('1 %s 1'%self._equality_symbol())
-
-    def _false_symbol(self):
-        try:
-            return self.__false_symbol
-        except AttributeError:
-            self.__false_symbol = self.eval('1 %s 2'%self._equality_symbol())
-
-    def _lessthan_symbol(self):
-        return '<'
-
-    def _greaterthan_symbol(self):
-        return '>'
-
-    def _inequality_symbol(self):
-        return '!='
-
-    def _relation_symbols(self):
-        """
-        Returns a dictionary with operators as the keys and their
-        string representation as the values.
-
-        EXAMPLES::
-
-            sage: import operator
-            sage: symbols = mathematica._relation_symbols()
-            sage: symbols[operator.eq]
-            '=='
-        """
-        return dict([(operator.eq, self._equality_symbol()), (operator.ne, self._inequality_symbol()),
-                     (operator.lt, self._lessthan_symbol()), (operator.le, "<="),
-                     (operator.gt, self._greaterthan_symbol()), (operator.ge, ">=")])
-
-    def _exponent_symbol(self):
-        """
-        Return the symbol used to denote *10^ in floats, e.g 'e' in 1.5e6
-        
-        EXAMPLES::
-            
-            sage: from sage.interfaces.expect import Expect
-            sage: Expect('nonexistent_interface', 'fake')._exponent_symbol()
-            'e'
-        """
-        return 'e'
-
     ############################################################
     #         Functions for working with variables.
     #  The first three must be overloaded by derived classes,
@@ -1242,52 +1035,6 @@
     #  the functionality one gets from this is very nice. 
     ############################################################
 
-    def set(self, var, value):
-        """
-        Set the variable var to the given value.
-        """
-        cmd = '%s%s%s;'%(var,self._assign_symbol(), value) 
-        self.eval(cmd)
-
-    def get(self, var):
-        """
-        Get the value of the variable var.
-        """
-        return self.eval(var)
-
-    def get_using_file(self, var):
-        r"""
-        Return the string representation of the variable var in self,
-        possibly using a file. Use this if var has a huge string
-        representation, since it may be way faster.
-        
-        .. warning::
-
-           In fact unless a special derived class implements this, it
-           will *not* be any faster. This is the case for this class
-           if you're reading it through introspection and seeing this.
-        """
-        return self.get(var)
-
-    def clear(self, var):
-        """
-        Clear the variable named var.
-        """
-        self._available_vars.append(var)
-    
-    def _next_var_name(self):
-        if len(self._available_vars) != 0:
-            v = self._available_vars[0]
-            del self._available_vars[0]
-            return v
-        self.__seq += 1
-        return "sage%s"%self.__seq
-
-    def _create(self, value, name=None):
-        name = self._next_var_name() if name is None else name
-        self.set(name, value)
-        return name
-
     def _object_class(self):
         """
         EXAMPLES::
@@ -1317,197 +1064,26 @@
             <class 'sage.interfaces.expect.FunctionElement'>
         """
         return FunctionElement
+  
 
-    def _convert_args_kwds(self, args=None, kwds=None):
-        """
-        Converts all of the args and kwds to be elements of this
-        interface.
-        
-        EXAMPLES::
-        
-            sage: args = [5]
-            sage: kwds = {'x': 6}
-            sage: args, kwds = gap._convert_args_kwds(args, kwds)
-            sage: args
-            [5]
-            sage: map(type, args)
-            [<class 'sage.interfaces.gap.GapElement'>]
-            sage: type(kwds['x'])
-            <class 'sage.interfaces.gap.GapElement'>
-        """
-        args = [] if args is None else args
-        kwds = {} if kwds is None else kwds
-        if not isinstance(args, list):
-            args = [args]
-        for i, arg in enumerate(args):
-            if not isinstance(arg, ExpectElement) or arg.parent() is not self:
-                args[i] = self(arg)
-        for key, value in kwds.iteritems():
-            if not isinstance(value, ExpectElement) or value.parent() is not self:
-                kwds[key] = self(value)
-
-        return args, kwds
-
-    def _check_valid_function_name(self, function):
-        """
-        Checks to see if function is a valid function name in this
-        interface. If it is not, an exception is raised. Otherwise, nothing
-        is done.
-        
-        EXAMPLES::
-        
-            sage: gap._check_valid_function_name('SymmetricGroup')
-            sage: gap._check_valid_function_name('')
-            Traceback (most recent call last):
-            ...
-            ValueError: function name must be nonempty
-            sage: gap._check_valid_function_name('__foo')
-            Traceback (most recent call last):
-            ...
-            AttributeError
-        """
-        if function == '':
-            raise ValueError, "function name must be nonempty"
-        if function[:2] == "__":
-            raise AttributeError        
-
-    def function_call(self, function, args=None, kwds=None):
-        """
-        EXAMPLES::
-        
-            sage: maxima.quad_qags(x, x, 0, 1, epsrel=1e-4)
-            [0.5,5.5511151231257...e-15,21,0]
-            sage: maxima.function_call('quad_qags', [x, x, 0, 1], {'epsrel':'1e-4'})
-            [0.5,5.5511151231257...e-15,21,0]
-        """
-        args, kwds = self._convert_args_kwds(args, kwds)
-        self._check_valid_function_name(function)
-        s = self._function_call_string(function,
-                                       [s.name() for s in args],
-                                       ['%s=%s'%(key,value.name()) for key, value in kwds.items()])
-        return self.new(s)
-
-    def _function_call_string(self, function, args, kwds):
-        """
-        Returns the string used to make function calls.
-        
-        EXAMPLES::
-
-            sage: maxima._function_call_string('diff', ['f(x)', 'x'], [])
-            'diff(f(x),x)'
-        """
-        return "%s(%s)"%(function, ",".join(list(args) + list(kwds)))
-            
-    def call(self, function_name, *args, **kwds):
-        return self.function_call(function_name, args, kwds)
-
-    def _contains(self, v1, v2):
-        raise NotImplementedError
-    
-    def __getattr__(self, attrname):
-        """
-        TESTS::
-
-            sage: ParentWithBase.__getattribute__(singular, '_coerce_map_from_')
-            <built-in method _coerce_map_from_ of Singular object at ...>
-        """
-        try:
-            return ParentWithBase.__getattribute__(self, attrname)
-        except AttributeError:
-            if attrname[:1] == "_":
-                raise AttributeError
-            return self._function_class()(self, attrname)
-
-    def __cmp__(self, other):
-        """
-        Compare two pseudo-tty interfaces. Two interfaces compare
-        equal if and only if they are identical objects (this is a
-        critical constraint so that caching of representations of
-        objects in interfaces works correctly). Otherwise they are
-        never equal.
-        
-        EXAMPLES::
-        
-            sage: Maxima() == maxima
-            False
-            sage: maxima == maxima
-            True
-        """
-        if self is other:
-            return 0
-        c = cmp(type(self), type(other))
-        if c:
-            return c
-        return -1  # sucky, but I can't think of anything better; it is important that different interfaces to the same system still compare differently; unfortunately there is nothing to distinguish them.
-
-    def console(self):
-        raise NotImplementedError
-
-    def help(self, s):
-        return AsciiArtString('No help on %s available'%s)
-    
-
-class ExpectFunction(SageObject):
+class ExpectFunction(InterfaceFunction):
     """
     Expect function.
     """
-    def __init__(self, parent, name):
-        self._parent = parent
-        self._name = name
-        
-    def __repr__(self):
-        return "%s"%self._name
-    
-    def __call__(self, *args, **kwds):
-        return self._parent.function_call(self._name, list(args), kwds)
-        
-    def _sage_doc_(self):
-        """
-        EXAMPLES::
-        
-            sage: gp.gcd._sage_doc_()
-            'gcd(x,{y}): greatest common divisor of x and y.'
-        """
-        M = self._parent
-        return M.help(self._name)
-        
+    pass
 
 
-        
-class FunctionElement(SageObject):
+class FunctionElement(InterfaceFunctionElement):
     """
     Expect function element.
     """
-    def __init__(self, obj, name):
-        self._obj = obj
-        self._name = name
-
-    def __repr__(self):
-        return "%s"%self._name
-
-    def __call__(self, *args, **kwds):
-        return self._obj.parent().function_call(self._name, [self._obj] + list(args), kwds)
-    
-    def help(self):
-        print self._sage_doc_()
-
-    def _sage_doc_(self):
-        """
-        EXAMPLES::
-        
-            sage: gp(2).gcd._sage_doc_()
-            'gcd(x,{y}): greatest common divisor of x and y.'
-        """
-        M = self._obj.parent()
-        return M.help(self._name)
+    pass
 
 
 def is_ExpectElement(x):
     return isinstance(x, ExpectElement)
 
-
-
-class ExpectElement(RingElement):
+class ExpectElement(InterfaceElement):
     """
     Expect element.
     """
@@ -1532,69 +1108,6 @@
                 raise TypeError, x
         self._session_number = parent._session_number
 
-    def _latex_(self):
-#        return "\\begin{verbatim}%s\\end{verbatim}"%self
-        string = str(self)
-        if not '|' in string:
-            delim = '|'
-        elif not '#' in string:
-            delim = '#'
-        elif not '@' in string:
-            delim = '@'
-        elif not '~' in string:
-            delim = '~'
-        return "\\verb%s%s%s"%(delim, string, delim)
-
-    def __iter__(self):
-        for i in range(1, len(self)+1):
-            yield self[i]
-
-    def __len__(self):
-        """
-        Call self.sage() and return the length of that sage object.
-        
-        This approach is inefficient - each interface should override
-        this method with one that calls the external program's length
-        function.
-        
-        EXAMPLES::
-        
-            sage: len(gp([1,2,3]))
-            3
-        
-        AUTHORS:
-        
-        - Felix Lawrence (2009-08-21)
-        """
-        return len(self.sage())
-
-    def __reduce__(self):
-        return reduce_load, (self.parent(), self._reduce())
-
-    def _reduce(self):
-        return repr(self)
-
-    def __call__(self, *args):
-        self._check_valid()                
-        P = self.parent()
-        return getattr(P, self.name())(*args)
-
-    def __contains__(self, x):
-        P = self._check_valid()                
-        if not isinstance(x, ExpectElement) or x.parent() is not self.parent():
-            x = P.new(x)
-        return P._contains(x.name(), self.name())
-
-
-    def _sage_doc_(self):
-        """
-        EXAMPLES::
-        
-            sage: gp(2)._sage_doc_()
-            '2'
-        """
-        return str(self)
-
     def __hash__(self):
         """
         Returns the hash of self. This is a default implementation of hash
@@ -1602,64 +1115,6 @@
         """
         return hash('%s%s'%(self, self._session_number))
     
-    def __cmp__(self, other):
-        """
-        Comparison is done by GAP.
-
-        GAP may raise an error when comparing objects. We catch these
-        errors. Moreover, GAP does not recognise certain objects as
-        equal even if there definitions are identical.
-
-        TESTS:
-
-        Here are examples in which GAP succeeds with a comparison::
-
-            sage: gap('SymmetricGroup(8)')==gap('SymmetricGroup(8)')
-            True
-            sage: gap('SymmetricGroup(8)')>gap('AlternatingGroup(8)')
-            False
-            sage: gap('SymmetricGroup(8)')<gap('AlternatingGroup(8)')
-            True
-
-        Here, GAP fails to compare, and so ``False`` is returned.
-        In previous Sage versions, this example actually resulted
-        in an error; compare #5962.
-        ::
-
-            sage: gap('DihedralGroup(8)')==gap('DihedralGroup(8)')
-            False
-
-        """
-        P = self.parent()
-        try:
-            if P.eval("%s %s %s"%(self.name(), P._equality_symbol(),
-                                     other.name())) == P._true_symbol():
-                return 0
-        except RuntimeError:
-            pass
-        try:
-            if P.eval("%s %s %s"%(self.name(), P._lessthan_symbol(), other.name())) == P._true_symbol():
-                return -1
-        except RuntimeError:
-            pass
-        try:
-            if P.eval("%s %s %s"%(self.name(), P._greaterthan_symbol(), other.name())) == P._true_symbol():
-                return 1
-        except:
-            pass
-
-        # everything is supposed to be comparable in Python, so we define
-        # the comparison thus when no comparison is available in interfaced system.
-        if (hash(self) < hash(other)):
-            return -1
-        else:
-            return 1
-
-    def _matrix_(self, R):
-        raise NotImplementedError
-
-    def _vector_(self, R):
-        raise NotImplementedError
 
     def _check_valid(self):
         """
@@ -1692,370 +1147,8 @@
             #print msg
             pass
 
-    def _sage_repr(self):
-        """
-        Return a sage-friendly string representation of the object.
-        
-        Some programs use different notation to Sage, e.g. Mathematica 
-        writes lists with {} instead of [].  This method calls repr(self) 
-        then converts the foreign notation into Sage's notation.
-        
-        OUTPUT:
-        
-        A string representation of the object that is ready for
-        sage_eval().
-        
-        EXAMPLES::
-        
-            sage: repr(mathematica([1,2,3]))    # optional - mathematica
-            '{1, 2, 3}'
-            sage: mathematica([1,2,3])._sage_repr() # optional - mathematica
-            '[1, 2, 3]'
-        
-        ::
-        
-            sage: gp(10.^80)._sage_repr()
-            '1.0000000000000000000000000000000000000e80'    # 64-bit
-            '1.000000000000000000000000000e80'              # 32-bit
-            sage: mathematica('10.^80')._sage_repr()  # optional - mathematica
-            '1.e80'
-        
-        AUTHORS:
-        
-        - Felix Lawrence (2009-08-21)
-        """
-        #TO DO: this could use file transfers when self.is_remote()
-        
-        string = repr(self).replace('\n',' ').replace('\r', '')
-        # Translate the external program's function notation to Sage's
-        lfd = self.parent()._left_func_delim()
-        if '(' != lfd:  string = string.replace(lfd, '(')
-        rfd = self.parent()._right_func_delim()
-        if ')' != rfd:  string = string.replace(rfd, ')')
-        # Translate the external program's list formatting to Sage's
-        lld = self.parent()._left_list_delim()
-        if '[' != lld:      string = string.replace(lld, '[')
-        rld = self.parent()._right_list_delim()
-        if ']' != rld:      string = string.replace(rld, ']')
-        # Translate the external program's exponent formatting
-        expl = self.parent()._exponent_symbol()
-        if 'e' != expl: string = string.replace(expl, 'e')
-        return string
-
-    def _sage_(self):
-        """
-        Attempt to return a Sage version of this object.
-        This is a generic routine that just tries to evaluate
-        the repr(self).
-
-        EXAMPLES::
-        
-            sage: gp(1/2)._sage_()
-            1/2
-            sage: _.parent()
-            Rational Field
-        
-        AUTHORS:
-        
-        - William Stein
-        
-        - Felix Lawrence (2009-08-21)
-        """
-        string = self._sage_repr()
-        try:
-            return sage.misc.sage_eval.sage_eval(string)
-        except:
-            raise NotImplementedError, "Unable to parse output: %s" % string
-        
-
-    def sage(self):
-        """
-        Attempt to return a Sage version of this object.
-
-        EXAMPLES::
-        
-            sage: gp(1/2).sage()
-            1/2
-            sage: _.parent()
-            Rational Field
-        """
-        return self._sage_()
-        
-    def __repr__(self):
-        self._check_valid()
-        try:
-            if self._get_using_file:
-                s = self.parent().get_using_file(self._name)
-        except AttributeError:
-            s = self.parent().get(self._name)
-        if s.__contains__(self._name):
-            if hasattr(self, '__custom_name'):
-                s =  s.replace(self._name, self.__dict__['__custom_name'])
-        return s
-
-    def __getattr__(self, attrname):
-        P = self._check_valid()
-        if attrname[:1] == "_":
-            raise AttributeError
-        return P._function_element_class()(self, attrname)
-
-    def get_using_file(self):
-        """
-        Return this element's string representation using a file. Use this
-        if self has a huge string representation. It'll be way faster.
-        
-        EXAMPLES::
-        
-            sage: a = maxima(str(2^1000))
-            sage: a.get_using_file()
-            '10715086071862673209484250490600018105614048117055336074437503883703510511249361224931983788156958581275946729175531468251871452856923140435984577574698574803934567774824230985421074605062371141877954182153046474983581941267398767559165543946077062914571196477686542167660429831652624386837205668069376'
-        """
-        try:
-            self._check_valid()
-        except ValueError:
-            return '(invalid object -- defined in terms of closed session)'
-        return self.parent().get_using_file(self._name)
-
-    def hasattr(self, attrname):
-        """
-        Returns whether the given attribute is already defined by this
-        object, and in particular is not dynamically generated.
-        
-        EXAMPLES::
-        
-            sage: m = maxima('2')
-            sage: m.hasattr('integral')
-            True
-            sage: m.hasattr('gcd')
-            False
-        """
-        return not isinstance(getattr(self, attrname), FunctionElement)
-
-    def attribute(self, attrname):
-        """
-        If this wraps the object x in the system, this returns the object
-        x.attrname. This is useful for some systems that have object
-        oriented attribute access notation.
-        
-        EXAMPLES::
-        
-            sage: g = gap('SO(1,4,7)')
-            sage: k = g.InvariantQuadraticForm()
-            sage: k.attribute('matrix')
-            [ [ 0*Z(7), Z(7)^0, 0*Z(7), 0*Z(7) ], [ 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7) ], 
-              [ 0*Z(7), 0*Z(7), Z(7), 0*Z(7) ], [ 0*Z(7), 0*Z(7), 0*Z(7), Z(7)^0 ] ]
-        
-        ::
-        
-            sage: e = gp('ellinit([0,-1,1,-10,-20])')
-            sage: e.attribute('j')
-            -122023936/161051
-        """
-        P = self._check_valid()
-        return P('%s.%s'%(self.name(), attrname))
-
-    def __getitem__(self, n):
-        P = self._check_valid()
-        if not isinstance(n, tuple):
-            return P.new('%s[%s]'%(self._name, n))
-        else:
-            return P.new('%s[%s]'%(self._name, str(n)[1:-1]))
-    
-    def __int__(self):
-        """
-        EXAMPLES::
-        
-            sage: int(maxima('1'))
-            1
-            sage: type(_)
-            <type 'int'>
-        """
-        return int(repr(self))
-
-    def bool(self):
-        P = self.parent()
-        t = P._true_symbol()
-        cmd = '%s %s %s'%(self._name, P._equality_symbol(), t)
-        return P.eval(cmd) == t
-
-    def __nonzero__(self):
-        """
-        EXAMPLES::
-        
-            sage: bool(maxima(0))
-            False
-            sage: bool(maxima(1))
-            True
-        """
-        return self.bool()
-
-    def __long__(self):
-        """
-        EXAMPLES::
-        
-            sage: m = maxima('1')
-            sage: long(m)
-            1L
-        """
-        return long(repr(self))
-
-    def __float__(self):
-        """
-        EXAMPLES::
-        
-            sage: m = maxima('1/2')
-            sage: m.__float__()
-            0.5
-            sage: float(m)
-            0.5
-        """
-        return float(repr(self))
-
-    def _integer_(self, ZZ=None):
-        """
-        EXAMPLES::
-        
-            sage: m = maxima('1')
-            sage: m._integer_()
-            1
-            sage: _.parent()
-            Integer Ring
-            sage: QQ(m)
-            1
-        """
-        import sage.rings.all
-        return sage.rings.all.Integer(repr(self))
-
-    def _rational_(self):
-        """
-        EXAMPLES::
-        
-            sage: m = maxima('1/2')
-            sage: m._rational_()
-            1/2
-            sage: _.parent()
-            Rational Field
-            sage: QQ(m)
-            1/2
-        """
-        import sage.rings.all        
-        return sage.rings.all.Rational(repr(self))
-
-    def name(self, new_name=None):
-        """
-        Returns the name of self. If new_name is passed in, then this
-        function returns a new object identical to self whose name is
-        new_name.
-        
-        Note that this can overwrite existing variables in the system.
-        
-        EXAMPLES::
-        
-            sage: x = r([1,2,3]); x
-            [1] 1 2 3
-            sage: x.name()
-            'sage3'
-            sage: x = r([1,2,3]).name('x'); x
-            [1] 1 2 3
-            sage: x.name()
-            'x'
-        
-        ::
-        
-            sage: s5 = gap.SymmetricGroup(5).name('s5')
-            sage: s5
-            SymmetricGroup( [ 1 .. 5 ] )
-            sage: s5.name()
-            's5'
-        """
-        if new_name is not None:
-            if not isinstance(new_name, str):
-                raise TypeError, "new_name must be a string"
-            p = self.parent()
-            p.set(new_name, self._name)
-            return p._object_class()(p, new_name, is_name=True)
-            
-        return self._name
-
-    def gen(self, n):
-        P = self._check_valid()
-        return P.new('%s.%s'%(self._name, int(n)))
-
-    def _operation(self, operation, right):
-        P = self._check_valid()
-        try:
-            return P.new('%s %s %s'%(self._name, operation, right._name))
-        except Exception, msg:
-            raise TypeError, msg
-
-    def _add_(self, right):
-        """
-        EXAMPLES::
-        
-            sage: f = maxima.cos(x)
-            sage: g = maxima.sin(x)
-            sage: f + g
-            sin(x)+cos(x)
-            sage: f + 2
-            cos(x)+2
-            sage: 2 + f
-            cos(x)+2
-        """
-        return self._operation("+", right)
-        
-    def _sub_(self, right):
-        """
-        EXAMPLES::
-        
-            sage: f = maxima.cos(x)
-            sage: g = maxima.sin(x)
-            sage: f - g
-            cos(x)-sin(x)
-            sage: f - 2
-            cos(x)-2
-            sage: 2 - f
-            2-cos(x)
-        """
-        return self._operation('-', right)       
-
-    def _mul_(self, right):
-        """
-        EXAMPLES::
-        
-            sage: f = maxima.cos(x)
-            sage: g = maxima.sin(x)
-            sage: f*g
-            cos(x)*sin(x)
-            sage: 2*f
-            2*cos(x)
-        """
-        return self._operation('*', right)
-
-    def _div_(self, right):
-        """        
-        EXAMPLES::
-        
-            sage: f = maxima.cos(x)
-            sage: g = maxima.sin(x)
-            sage: f/g
-            cos(x)/sin(x)
-            sage: f/2
-            cos(x)/2
-        """
-        return self._operation("/", right)
-
-    def __pow__(self, n):
-        """
-        EXAMPLES::
-        
-            sage: a = maxima('2')
-            sage: a^(3/4)
-            2^(3/4)
-        """
-        P = self._check_valid()
-        if not hasattr(n, 'parent') or P is not n.parent():
-            n = P(n)
-        return self._operation("^", n)
+#    def _sage_repr(self):
+#TO DO: this could use file transfers when self.is_remote()
 
 
 class StdOutContext:
@@ -2082,7 +1175,7 @@
             sage: with StdOutContext(gp):
             ...       gp('1+1')
             ...
-            sage[...
+            sage=...
         """
         self.interface = interface
         self.silent = silent
@@ -2124,9 +1217,6 @@
         self.stdout.write("\n")
         self.interface._expect.logfile = self._logfile_backup
 
-def reduce_load(parent, x):
-    return parent(x)
-
 import os
 def console(cmd):
     os.system(cmd)
diff -r df3ffca81588 -r e20fb42bdea9 sage/interfaces/gap.py
--- a/sage/interfaces/gap.py	Tue Feb 15 17:14:05 2011 +0100
+++ b/sage/interfaces/gap.py	Mon Feb 14 14:06:15 2011 +0100
@@ -599,7 +599,7 @@
         
             sage: s = gap.function_call('Display', [gap.SymmetricGroup(5).CharacterTable()])
             sage: type(s)
-            <class 'sage.interfaces.expect.AsciiArtString'>
+            <class 'sage.interfaces.interface.AsciiArtString'>
             sage: s.startswith('CT')
             True
         """
diff -r df3ffca81588 -r e20fb42bdea9 sage/interfaces/interface.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/interfaces/interface.py	Mon Feb 14 14:06:15 2011 +0100
@@ -0,0 +1,1146 @@
+r"""
+Common Interface Functionality
+
+See the examples in the other sections for how to use specific
+interfaces. The interface classes all derive from the generic
+interface that is described in this section.
+
+AUTHORS:
+
+- William Stein (2005): initial version
+
+- William Stein (2006-03-01): got rid of infinite loop on startup if
+  client system missing
+
+- Felix Lawrence (2009-08-21): edited ._sage_() to support lists and float exponents in foreign notation.
+
+- Simon King (2010-09-25): Expect._local_tmpfile() depends on
+  Expect.pid() and is cached; Expect.quit() clears that cache,
+  which is important for forking.
+"""
+
+#*****************************************************************************
+#       Copyright (C) 2005 William Stein <wstein@gmail.com>
+#
+#  Distributed under the terms of the GNU General Public License (GPL)
+#
+#    This code is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#    General Public License for more details.
+#
+#  The full text of the GPL is available at:
+#
+#                  http://www.gnu.org/licenses/
+#*****************************************************************************
+
+import operator
+
+from sage.structure.sage_object import SageObject
+from sage.structure.parent_base import ParentWithBase
+from sage.structure.element import RingElement
+
+from sage.misc.sage_eval import sage_eval
+
+from sage.misc.misc import SAGE_ROOT, verbose, SAGE_TMP_INTERFACE, LOCAL_IDENTIFIER
+
+class AsciiArtString(str):
+    def __repr__(self):
+        return str(self)
+
+class PropTypeError(Exception):
+    pass
+    
+
+class Interface(ParentWithBase):
+    """
+    Interface interface object.
+    """
+    def __init__(self, name):
+        self.__name = name
+        self.__coerce_name = '_' + name.lower() + '_'
+        self.__seq = -1
+        self._available_vars = []
+        ParentWithBase.__init__(self, self)
+
+    def _repr_(self):
+        return self.__name.capitalize()
+
+    def name(self, new_name=None):
+        return self.__name
+
+    def interact(self):
+        r"""
+        This allows you to interactively interact with the child
+        interpreter. Press Ctrl-D or type 'quit' or 'exit' to exit and
+        return to Sage.
+        
+        .. note::
+
+           This is completely different than the console() member
+           function. The console function opens a new copy of the
+           child interpreter, whereas the interact function gives you
+           interactive access to the interpreter that is being used by
+           Sage. Use sage(xxx) or interpretername(xxx) to pull objects
+           in from sage to the interpreter.
+        """
+        import sage.misc.preparser_ipython
+        sage.misc.preparser_ipython.switch_interface_general(self)
+
+    def _pre_interact(self):
+        pass
+
+    def _post_interact(self):
+        pass
+
+    def __del__(self):
+        pass
+
+    def cputime(self):
+        """
+        CPU time since this process started running.
+        """
+        raise NotImplementedError
+
+    def read(self, filename):
+        r"""
+        EXAMPLES::
+        
+            sage: filename = tmp_filename()
+            sage: f = open(filename, 'w')
+            sage: f.write('x = 2\n')
+            sage: f.close()
+            sage: octave.read(filename)  #optional -- requires Octave
+            sage: octave.get('x')        #optional
+            ' 2'
+            sage: import os
+            sage: os.unlink(filename)
+        """
+        self.eval(self._read_in_file_command(filename))
+
+    def _read_in_file_command(self, filename):
+        raise NotImplementedError
+
+    def eval(self, code, locals=None, **kwds):
+        """
+        INPUT:
+        
+        
+        -  ``code`` - text to evaluate
+                
+        - ``locals`` - None (ignored); this is used for compatibility with the
+          Sage notebook's generic system interface.
+         
+        -  ``**kwds`` - All other arguments are passed onto
+           the _eval_line method. An often useful example is
+           reformat=False.
+        """
+
+        if not isinstance(code, basestring):
+            raise TypeError, 'input code must be a string.'
+
+        #Remove extra whitespace
+        code = code.strip()
+        
+        try:
+            pass
+        except KeyboardInterrupt:
+            # DO NOT CATCH KeyboardInterrupt, as it is being caught
+            # by _eval_line
+            # In particular, do NOT call self._keyboard_interrupt()
+            raise
+        except TypeError, s:
+            raise TypeError, 'error evaluating "%s":\n%s'%(code,s)
+
+    _eval_line = eval
+
+    def execute(self, *args, **kwds):
+        return self.eval(*args, **kwds)
+
+    def __call__(self, x, name=None):
+
+        r"""
+        Create a new object in self from x.
+
+        The object X returned can be used like any Sage object, and
+        wraps an object in self.  The standard arithmetic operators
+        work.  Moreover if foo is a function then
+                      X.foo(y,z,...)
+        calls foo(X, y, z, ...) and returns the corresponding object.
+
+        EXAMPLES::
+        
+            sage: gp(2)
+            2
+            sage: gp('2')
+            2
+            sage: a = gp(2); gp(a) is a
+            True
+
+        """
+        cls = self._object_class()
+
+        #Handle the case when x is an object
+        #in some interface.
+        if isinstance(x, InterfaceElement):
+            if x.parent() is self:
+                return x
+
+            #We convert x into an object in this
+            #interface by first going through Sage.
+            try:
+                return self(x._sage_())
+            except (NotImplementedError, TypeError):
+                pass
+            
+        if isinstance(x, basestring):
+            return cls(self, x, name=name)
+        try:
+            return self._coerce_from_special_method(x)
+        except TypeError:
+            raise
+        except AttributeError, msg:
+            pass
+        try:
+            return self._coerce_impl(x, use_special=False)
+        except TypeError, msg:
+            try:
+                return cls(self, str(x), name=name)
+            except TypeError, msg2:
+                raise TypeError, msg
+
+    def _coerce_from_special_method(self, x):
+        """
+        Tries to coerce to self by calling a special underscore method.
+        
+        If no such method is defined, raises an AttributeError instead of a
+        TypeError.
+        """
+        s = '_%s_'%self.name()
+        if s == '_maxima_lib_':
+            s = '_maxima_'
+        if s == '_pari_':
+            s = '_gp_'
+        try:
+            return (x.__getattribute__(s))(self)
+        except AttributeError:
+            return self(x._interface_init_())
+            
+    def _coerce_impl(self, x, use_special=True):
+        if isinstance(x, (int, long)):
+            import sage.rings.all
+            return self(sage.rings.all.Integer(x))
+        elif isinstance(x, float):
+            import sage.rings.all
+            return self(sage.rings.all.RDF(x))
+        if use_special:
+            try:
+                return self._coerce_from_special_method(x)
+            except AttributeError, msg:
+                pass
+            
+        if isinstance(x, (list, tuple)):
+            A = []
+            z = []
+            cls = self._object_class()
+            for v in x:
+                if isinstance(v, cls):
+                    A.append(v.name())
+                    z.append(v)
+                else:
+                    w = self(v)
+                    A.append(w.name())
+                    z.append(w)
+            X = ','.join(A)
+            r = self.new('%s%s%s'%(self._left_list_delim(), X, self._right_list_delim()))
+            r.__sage_list = z   # do this to avoid having the entries of the list be garbage collected
+            return r
+
+        raise TypeError, "unable to coerce element into %s"%self.name()
+
+    def new(self, code):
+        return self(code)
+
+    ###################################################################
+    # these should all be appropriately overloaded by the derived class
+    ###################################################################
+    
+    def _left_list_delim(self):
+        return "["
+    
+    def _right_list_delim(self):
+        return "]"
+    
+    def _left_func_delim(self):
+        return "("
+    
+    def _right_func_delim(self):
+        return ")"
+    
+    def _assign_symbol(self):
+        return "="
+    
+    def _equality_symbol(self):
+        raise NotImplementedError
+
+    # For efficiency purposes, you should definitely override these
+    # in your derived class.
+    def _true_symbol(self):
+        try:
+            return self.__true_symbol
+        except AttributeError:
+            self.__true_symbol = self.eval('1 %s 1'%self._equality_symbol())
+
+    def _false_symbol(self):
+        try:
+            return self.__false_symbol
+        except AttributeError:
+            self.__false_symbol = self.eval('1 %s 2'%self._equality_symbol())
+
+    def _lessthan_symbol(self):
+        return '<'
+
+    def _greaterthan_symbol(self):
+        return '>'
+
+    def _inequality_symbol(self):
+        return '!='
+
+    def _relation_symbols(self):
+        """
+        Returns a dictionary with operators as the keys and their
+        string representation as the values.
+
+        EXAMPLES::
+
+            sage: import operator
+            sage: symbols = mathematica._relation_symbols()
+            sage: symbols[operator.eq]
+            '=='
+        """
+        return dict([(operator.eq, self._equality_symbol()), (operator.ne, self._inequality_symbol()),
+                     (operator.lt, self._lessthan_symbol()), (operator.le, "<="),
+                     (operator.gt, self._greaterthan_symbol()), (operator.ge, ">=")])
+
+    def _exponent_symbol(self):
+        """
+        Return the symbol used to denote *10^ in floats, e.g 'e' in 1.5e6
+        
+        EXAMPLES::
+            
+            sage: from sage.interfaces.expect import Expect
+            sage: Expect('nonexistent_interface', 'fake')._exponent_symbol()
+            'e'
+        """
+        return 'e'
+
+    ############################################################
+    #         Functions for working with variables.
+    #  The first three must be overloaded by derived classes,
+    #  and the definition depends a lot on the class.  But
+    #  the functionality one gets from this is very nice. 
+    ############################################################
+
+    def set(self, var, value):
+        """
+        Set the variable var to the given value.
+        """
+        cmd = '%s%s%s;'%(var,self._assign_symbol(), value) 
+        self.eval(cmd)
+
+    def get(self, var):
+        """
+        Get the value of the variable var.
+        """
+        return self.eval(var)
+
+    def get_using_file(self, var):
+        r"""
+        Return the string representation of the variable var in self,
+        possibly using a file. Use this if var has a huge string
+        representation, since it may be way faster.
+        
+        .. warning::
+
+           In fact unless a special derived class implements this, it
+           will *not* be any faster. This is the case for this class
+           if you're reading it through introspection and seeing this.
+        """
+        return self.get(var)
+
+    def clear(self, var):
+        """
+        Clear the variable named var.
+        """
+        self._available_vars.append(var)
+    
+    def _next_var_name(self):
+        if len(self._available_vars) != 0:
+            v = self._available_vars[0]
+            del self._available_vars[0]
+            return v
+        self.__seq += 1
+        return "sage%s"%self.__seq
+
+    def _create(self, value, name=None):
+        name = self._next_var_name() if name is None else name
+        self.set(name, value)
+        return name
+
+    def _object_class(self):
+        """
+        EXAMPLES::
+        
+            sage: from sage.interfaces.expect import Expect
+            sage: Expect._object_class(maxima)
+            <class 'sage.interfaces.expect.ExpectElement'>
+        """
+        return InterfaceElement
+
+    def _function_class(self):
+        """
+        EXAMPLES::
+        
+            sage: from sage.interfaces.interface import Interface
+            sage: Interface._function_class(maxima)
+            <class 'sage.interfaces.interface.InterfaceFunction'>
+        """
+        return InterfaceFunction
+
+    def _function_element_class(self):
+        """
+        EXAMPLES::
+        
+            sage: from sage.interfaces.interface import Interface
+            sage: Interface._function_element_class(maxima)
+            <class 'sage.interfaces.interface.InterfaceFunctionElement'>
+        """
+        return InterfaceFunctionElement
+
+    def _convert_args_kwds(self, args=None, kwds=None):
+        """
+        Converts all of the args and kwds to be elements of this
+        interface.
+        
+        EXAMPLES::
+        
+            sage: args = [5]
+            sage: kwds = {'x': 6}
+            sage: args, kwds = gap._convert_args_kwds(args, kwds)
+            sage: args
+            [5]
+            sage: map(type, args)
+            [<class 'sage.interfaces.gap.GapElement'>]
+            sage: type(kwds['x'])
+            <class 'sage.interfaces.gap.GapElement'>
+        """
+        args = [] if args is None else args
+        kwds = {} if kwds is None else kwds
+        if not isinstance(args, list):
+            args = [args]
+        for i, arg in enumerate(args):
+            if not isinstance(arg, InterfaceElement) or arg.parent() is not self:
+                args[i] = self(arg)
+        for key, value in kwds.iteritems():
+            if not isinstance(value, InterfaceElement) or value.parent() is not self:
+                kwds[key] = self(value)
+
+        return args, kwds
+
+    def _check_valid_function_name(self, function):
+        """
+        Checks to see if function is a valid function name in this
+        interface. If it is not, an exception is raised. Otherwise, nothing
+        is done.
+        
+        EXAMPLES::
+        
+            sage: gap._check_valid_function_name('SymmetricGroup')
+            sage: gap._check_valid_function_name('')
+            Traceback (most recent call last):
+            ...
+            ValueError: function name must be nonempty
+            sage: gap._check_valid_function_name('__foo')
+            Traceback (most recent call last):
+            ...
+            AttributeError
+        """
+        if function == '':
+            raise ValueError, "function name must be nonempty"
+        if function[:2] == "__":
+            raise AttributeError        
+
+    def function_call(self, function, args=None, kwds=None):
+        """
+        EXAMPLES::
+        
+            sage: maxima.quad_qags(x, x, 0, 1, epsrel=1e-4)
+            [0.5,5.5511151231257...e-15,21,0]
+            sage: maxima.function_call('quad_qags', [x, x, 0, 1], {'epsrel':'1e-4'})
+            [0.5,5.5511151231257...e-15,21,0]
+        """
+        args, kwds = self._convert_args_kwds(args, kwds)
+        self._check_valid_function_name(function)
+        s = self._function_call_string(function,
+                                       [s.name() for s in args],
+                                       ['%s=%s'%(key,value.name()) for key, value in kwds.items()])
+        return self.new(s)
+
+    def _function_call_string(self, function, args, kwds):
+        """
+        Returns the string used to make function calls.
+        
+        EXAMPLES::
+
+            sage: maxima._function_call_string('diff', ['f(x)', 'x'], [])
+            'diff(f(x),x)'
+        """
+        return "%s(%s)"%(function, ",".join(list(args) + list(kwds)))
+            
+    def call(self, function_name, *args, **kwds):
+        return self.function_call(function_name, args, kwds)
+
+    def _contains(self, v1, v2):
+        raise NotImplementedError
+    
+    def __getattr__(self, attrname):
+        """
+        TESTS::
+
+            sage: ParentWithBase.__getattribute__(singular, '_coerce_map_from_')
+            <built-in method _coerce_map_from_ of Singular object at ...>
+        """
+        try:
+            return ParentWithBase.__getattribute__(self, attrname)
+        except AttributeError:
+            if attrname[:1] == "_":
+                raise AttributeError
+            return self._function_class()(self, attrname)
+
+    def __cmp__(self, other):
+        """
+        Compare two pseudo-tty interfaces. Two interfaces compare
+        equal if and only if they are identical objects (this is a
+        critical constraint so that caching of representations of
+        objects in interfaces works correctly). Otherwise they are
+        never equal.
+        
+        EXAMPLES::
+        
+            sage: Maxima() == maxima
+            False
+            sage: maxima == maxima
+            True
+        """
+        if self is other:
+            return 0
+        c = cmp(type(self), type(other))
+        if c:
+            return c
+        return -1  # sucky, but I can't think of anything better; it is important that different interfaces to the same system still compare differently; unfortunately there is nothing to distinguish them.
+
+    def console(self):
+        raise NotImplementedError
+
+    def help(self, s):
+        return AsciiArtString('No help on %s available'%s)
+    
+
+class InterfaceFunction(SageObject):
+    """
+    Interface function.
+    """
+    def __init__(self, parent, name):
+        self._parent = parent
+        self._name = name
+        
+    def __repr__(self):
+        return "%s"%self._name
+    
+    def __call__(self, *args, **kwds):
+        return self._parent.function_call(self._name, list(args), kwds)
+        
+    def _sage_doc_(self):
+        """
+        EXAMPLES::
+        
+            sage: gp.gcd._sage_doc_()
+            'gcd(x,{y}): greatest common divisor of x and y.'
+        """
+        M = self._parent
+        return M.help(self._name)
+        
+        
+class InterfaceFunctionElement(SageObject):
+    """
+    Interface function element.
+    """
+    def __init__(self, obj, name):
+        self._obj = obj
+        self._name = name
+
+    def __repr__(self):
+        return "%s"%self._name
+
+    def __call__(self, *args, **kwds):
+        return self._obj.parent().function_call(self._name, [self._obj] + list(args), kwds)
+    
+    def help(self):
+        print self._sage_doc_()
+
+    def _sage_doc_(self):
+        """
+        EXAMPLES::
+        
+            sage: gp(2).gcd._sage_doc_()
+            'gcd(x,{y}): greatest common divisor of x and y.'
+        """
+        M = self._obj.parent()
+        return M.help(self._name)
+
+
+
+def is_InterfaceElement(x):
+    return isinstance(x, InterfaceElement)
+
+class InterfaceElement(RingElement):
+    """
+    Interface element.
+    """
+    def __init__(self, parent, value, is_name=False, name=None):
+        RingElement.__init__(self, parent)
+        self._create = value
+        if parent is None: return     # means "invalid element"
+        # idea: Joe Wetherell -- try to find out if the output
+        # is too long and if so get it using file, otherwise
+        # don't.
+            
+        if is_name:
+            self._name = value
+        else:
+            try:
+                self._name = parent._create(value, name=name)
+            except (TypeError, KeyboardInterrupt, RuntimeError, ValueError), x:
+                raise TypeError, x
+
+    def _latex_(self):
+#        return "\\begin{verbatim}%s\\end{verbatim}"%self
+        string = str(self)
+        if not '|' in string:
+            delim = '|'
+        elif not '#' in string:
+            delim = '#'
+        elif not '@' in string:
+            delim = '@'
+        elif not '~' in string:
+            delim = '~'
+        return "\\verb%s%s%s"%(delim, string, delim)
+
+    def __iter__(self):
+        for i in range(1, len(self)+1):
+            yield self[i]
+
+    def __len__(self):
+        """
+        Call self.sage() and return the length of that sage object.
+        
+        This approach is inefficient - each interface should override
+        this method with one that calls the external program's length
+        function.
+        
+        EXAMPLES::
+        
+            sage: len(gp([1,2,3]))
+            3
+        
+        AUTHORS:
+        
+        - Felix Lawrence (2009-08-21)
+        """
+        return len(self.sage())
+
+    def __reduce__(self):
+        return reduce_load, (self.parent(), self._reduce())
+
+    def _reduce(self):
+        return repr(self)
+
+    def __call__(self, *args):
+        self._check_valid()                
+        P = self.parent()
+        return getattr(P, self.name())(*args)
+
+    def __contains__(self, x):
+        P = self._check_valid()                
+        if not isinstance(x, InterfaceElement) or x.parent() is not self.parent():
+            x = P.new(x)
+        return P._contains(x.name(), self.name())
+
+
+    def _sage_doc_(self):
+        """
+        EXAMPLES::
+        
+            sage: gp(2)._sage_doc_()
+            '2'
+        """
+        return str(self)
+
+    def __hash__(self):
+        """
+        Returns the hash of self. This is a default implementation of hash
+        which just takes the hash of the string of self.
+        """
+        return hash('%s'%(self))
+    
+    def __cmp__(self, other):
+        """
+        Comparison is done by GAP.
+
+        GAP may raise an error when comparing objects. We catch these
+        errors. Moreover, GAP does not recognise certain objects as
+        equal even if there definitions are identical.
+
+        TESTS:
+
+        Here are examples in which GAP succeeds with a comparison::
+
+            sage: gap('SymmetricGroup(8)')==gap('SymmetricGroup(8)')
+            True
+            sage: gap('SymmetricGroup(8)')>gap('AlternatingGroup(8)')
+            False
+            sage: gap('SymmetricGroup(8)')<gap('AlternatingGroup(8)')
+            True
+
+        Here, GAP fails to compare, and so ``False`` is returned.
+        In previous Sage versions, this example actually resulted
+        in an error; compare #5962.
+        ::
+
+            sage: gap('DihedralGroup(8)')==gap('DihedralGroup(8)')
+            False
+
+        """
+        P = self.parent()
+        try:
+            if P.eval("%s %s %s"%(self.name(), P._equality_symbol(),
+                                     other.name())) == P._true_symbol():
+                return 0
+        except RuntimeError:
+            pass
+        try:
+            if P.eval("%s %s %s"%(self.name(), P._lessthan_symbol(), other.name())) == P._true_symbol():
+                return -1
+        except RuntimeError:
+            pass
+        try:
+            if P.eval("%s %s %s"%(self.name(), P._greaterthan_symbol(), other.name())) == P._true_symbol():
+                return 1
+        except:
+            pass
+
+        # everything is supposed to be comparable in Python, so we define
+        # the comparison thus when no comparison is available in interfaced system.
+        if (hash(self) < hash(other)):
+            return -1
+        else:
+            return 1
+
+    def _matrix_(self, R):
+        raise NotImplementedError
+
+    def _vector_(self, R):
+        raise NotImplementedError
+
+    def _check_valid(self):
+        """
+        Check that this object is valid, i.e., the session in which this
+        object is defined is still running. This is relevant for
+        interpreters that can't be interrupted via ctrl-C, hence get
+        restarted.
+        """
+        try:
+            P = self.parent()
+            if P is None:
+                raise ValueError, "The %s session in which this object was defined is no longer running."%P.name()
+        except AttributeError:
+            raise ValueError, "The session in which this object was defined is no longer running."
+        return P
+
+    def __del__(self):
+        try:
+            self._check_valid()
+        except ValueError:
+            return
+        if hasattr(self,'_name'):
+            P = self.parent()
+            if not (P is None):
+                P.clear(self._name)
+                
+    def _sage_repr(self):
+        """
+        Return a sage-friendly string representation of the object.
+        
+        Some programs use different notation to Sage, e.g. Mathematica 
+        writes lists with {} instead of [].  This method calls repr(self) 
+        then converts the foreign notation into Sage's notation.
+        
+        OUTPUT:
+        
+        A string representation of the object that is ready for
+        sage_eval().
+        
+        EXAMPLES::
+        
+            sage: repr(mathematica([1,2,3]))    # optional - mathematica
+            '{1, 2, 3}'
+            sage: mathematica([1,2,3])._sage_repr() # optional - mathematica
+            '[1, 2, 3]'
+        
+        ::
+        
+            sage: gp(10.^80)._sage_repr()
+            '1.0000000000000000000000000000000000000e80'    # 64-bit
+            '1.000000000000000000000000000e80'              # 32-bit
+            sage: mathematica('10.^80')._sage_repr()  # optional - mathematica
+            '1.e80'
+        
+        AUTHORS:
+        
+        - Felix Lawrence (2009-08-21)
+        """
+        #TO DO: this could use file transfers when self.is_remote()
+        
+        string = repr(self).replace('\n',' ').replace('\r', '')
+        # Translate the external program's function notation to Sage's
+        lfd = self.parent()._left_func_delim()
+        if '(' != lfd:  string = string.replace(lfd, '(')
+        rfd = self.parent()._right_func_delim()
+        if ')' != rfd:  string = string.replace(rfd, ')')
+        # Translate the external program's list formatting to Sage's
+        lld = self.parent()._left_list_delim()
+        if '[' != lld:      string = string.replace(lld, '[')
+        rld = self.parent()._right_list_delim()
+        if ']' != rld:      string = string.replace(rld, ']')
+        # Translate the external program's exponent formatting
+        expl = self.parent()._exponent_symbol()
+        if 'e' != expl: string = string.replace(expl, 'e')
+        return string
+
+    def _sage_(self):
+        """
+        Attempt to return a Sage version of this object.
+        This is a generic routine that just tries to evaluate
+        the repr(self).
+
+        EXAMPLES::
+        
+            sage: gp(1/2)._sage_()
+            1/2
+            sage: _.parent()
+            Rational Field
+        
+        AUTHORS:
+        
+        - William Stein
+        
+        - Felix Lawrence (2009-08-21)
+        """
+        string = self._sage_repr()
+        try:
+            return sage.misc.sage_eval.sage_eval(string)
+        except:
+            raise NotImplementedError, "Unable to parse output: %s" % string
+        
+
+    def sage(self):
+        """
+        Attempt to return a Sage version of this object.
+
+        EXAMPLES::
+        
+            sage: gp(1/2).sage()
+            1/2
+            sage: _.parent()
+            Rational Field
+        """
+        return self._sage_()
+        
+    def __repr__(self):
+        self._check_valid()
+        try:
+            if self._get_using_file:
+                s = self.parent().get_using_file(self._name)
+        except AttributeError:
+            s = self.parent().get(self._name)
+        if s.__contains__(self._name):
+            if hasattr(self, '__custom_name'):
+                s =  s.replace(self._name, self.__dict__['__custom_name'])
+        return s
+
+    def __getattr__(self, attrname):
+        P = self._check_valid()
+        if attrname[:1] == "_":
+            raise AttributeError
+        return P._function_element_class()(self, attrname)
+
+    def get_using_file(self):
+        """
+        Return this element's string representation using a file. Use this
+        if self has a huge string representation. It'll be way faster.
+        
+        EXAMPLES::
+        
+            sage: a = maxima(str(2^1000))
+            sage: a.get_using_file()
+            '10715086071862673209484250490600018105614048117055336074437503883703510511249361224931983788156958581275946729175531468251871452856923140435984577574698574803934567774824230985421074605062371141877954182153046474983581941267398767559165543946077062914571196477686542167660429831652624386837205668069376'
+        """
+        try:
+            self._check_valid()
+        except ValueError:
+            return '(invalid object -- defined in terms of closed session)'
+        return self.parent().get_using_file(self._name)
+
+    def hasattr(self, attrname):
+        """
+        Returns whether the given attribute is already defined by this
+        object, and in particular is not dynamically generated.
+        
+        EXAMPLES::
+        
+            sage: m = maxima('2')
+            sage: m.hasattr('integral')
+            True
+            sage: m.hasattr('gcd')
+            False
+        """
+        return not isinstance(getattr(self, attrname), InterfaceFunctionElement)
+
+    def attribute(self, attrname):
+        """
+        If this wraps the object x in the system, this returns the object
+        x.attrname. This is useful for some systems that have object
+        oriented attribute access notation.
+        
+        EXAMPLES::
+        
+            sage: g = gap('SO(1,4,7)')
+            sage: k = g.InvariantQuadraticForm()
+            sage: k.attribute('matrix')
+            [ [ 0*Z(7), Z(7)^0, 0*Z(7), 0*Z(7) ], [ 0*Z(7), 0*Z(7), 0*Z(7), 0*Z(7) ], 
+              [ 0*Z(7), 0*Z(7), Z(7), 0*Z(7) ], [ 0*Z(7), 0*Z(7), 0*Z(7), Z(7)^0 ] ]
+        
+        ::
+        
+            sage: e = gp('ellinit([0,-1,1,-10,-20])')
+            sage: e.attribute('j')
+            -122023936/161051
+        """
+        P = self._check_valid()
+        return P('%s.%s'%(self.name(), attrname))
+
+    def __getitem__(self, n):
+        P = self._check_valid()
+        if not isinstance(n, tuple):
+            return P.new('%s[%s]'%(self._name, n))
+        else:
+            return P.new('%s[%s]'%(self._name, str(n)[1:-1]))
+    
+    def __int__(self):
+        """
+        EXAMPLES::
+        
+            sage: int(maxima('1'))
+            1
+            sage: type(_)
+            <type 'int'>
+        """
+        return int(repr(self))
+
+    def bool(self):
+        P = self.parent()
+        t = P._true_symbol()
+        cmd = '%s %s %s'%(self._name, P._equality_symbol(), t)
+        return P.eval(cmd) == t
+
+    def __nonzero__(self):
+        """
+        EXAMPLES::
+        
+            sage: bool(maxima(0))
+            False
+            sage: bool(maxima(1))
+            True
+        """
+        return self.bool()
+
+    def __long__(self):
+        """
+        EXAMPLES::
+        
+            sage: m = maxima('1')
+            sage: long(m)
+            1L
+        """
+        return long(repr(self))
+
+    def __float__(self):
+        """
+        EXAMPLES::
+        
+            sage: m = maxima('1/2')
+            sage: m.__float__()
+            0.5
+            sage: float(m)
+            0.5
+        """
+        return float(repr(self))
+
+    def _integer_(self, ZZ=None):
+        """
+        EXAMPLES::
+        
+            sage: m = maxima('1')
+            sage: m._integer_()
+            1
+            sage: _.parent()
+            Integer Ring
+            sage: QQ(m)
+            1
+        """
+        import sage.rings.all
+        return sage.rings.all.Integer(repr(self))
+
+    def _rational_(self):
+        """
+        EXAMPLES::
+        
+            sage: m = maxima('1/2')
+            sage: m._rational_()
+            1/2
+            sage: _.parent()
+            Rational Field
+            sage: QQ(m)
+            1/2
+        """
+        import sage.rings.all        
+        return sage.rings.all.Rational(repr(self))
+
+    def name(self, new_name=None):
+        """
+        Returns the name of self. If new_name is passed in, then this
+        function returns a new object identical to self whose name is
+        new_name.
+        
+        Note that this can overwrite existing variables in the system.
+        
+        EXAMPLES::
+        
+            sage: x = r([1,2,3]); x
+            [1] 1 2 3
+            sage: x.name()
+            'sage3'
+            sage: x = r([1,2,3]).name('x'); x
+            [1] 1 2 3
+            sage: x.name()
+            'x'
+        
+        ::
+        
+            sage: s5 = gap.SymmetricGroup(5).name('s5')
+            sage: s5
+            SymmetricGroup( [ 1 .. 5 ] )
+            sage: s5.name()
+            's5'
+        """
+        if new_name is not None:
+            if not isinstance(new_name, str):
+                raise TypeError, "new_name must be a string"
+            p = self.parent()
+            p.set(new_name, self._name)
+            return p._object_class()(p, new_name, is_name=True)
+            
+        return self._name
+
+    def gen(self, n):
+        P = self._check_valid()
+        return P.new('%s.%s'%(self._name, int(n)))
+
+    def _operation(self, operation, right):
+        P = self._check_valid()
+        try:
+            return P.new('%s %s %s'%(self._name, operation, right._name))
+        except Exception, msg:
+            raise TypeError, msg
+
+    def _add_(self, right):
+        """
+        EXAMPLES::
+        
+            sage: f = maxima.cos(x)
+            sage: g = maxima.sin(x)
+            sage: f + g
+            sin(x)+cos(x)
+            sage: f + 2
+            cos(x)+2
+            sage: 2 + f
+            cos(x)+2
+        """
+        return self._operation("+", right)
+        
+    def _sub_(self, right):
+        """
+        EXAMPLES::
+        
+            sage: f = maxima.cos(x)
+            sage: g = maxima.sin(x)
+            sage: f - g
+            cos(x)-sin(x)
+            sage: f - 2
+            cos(x)-2
+            sage: 2 - f
+            2-cos(x)
+        """
+        return self._operation('-', right)       
+
+    def _mul_(self, right):
+        """
+        EXAMPLES::
+        
+            sage: f = maxima.cos(x)
+            sage: g = maxima.sin(x)
+            sage: f*g
+            cos(x)*sin(x)
+            sage: 2*f
+            2*cos(x)
+        """
+        return self._operation('*', right)
+
+    def _div_(self, right):
+        """        
+        EXAMPLES::
+        
+            sage: f = maxima.cos(x)
+            sage: g = maxima.sin(x)
+            sage: f/g
+            cos(x)/sin(x)
+            sage: f/2
+            cos(x)/2
+        """
+        return self._operation("/", right)
+
+    def __pow__(self, n):
+        """
+        EXAMPLES::
+        
+            sage: a = maxima('2')
+            sage: a^(3/4)
+            2^(3/4)
+        """
+        P = self._check_valid()
+        if not hasattr(n, 'parent') or P is not n.parent():
+            n = P(n)
+        return self._operation("^", n)
+
+def reduce_load(parent, x):
+    return parent(x)
diff -r df3ffca81588 -r e20fb42bdea9 sage/interfaces/maxima.py
--- a/sage/interfaces/maxima.py	Tue Feb 15 17:14:05 2011 +0100
+++ b/sage/interfaces/maxima.py	Mon Feb 14 14:06:15 2011 +0100
@@ -45,7 +45,7 @@
     sage: F
     -(y-x)*(y^4+x*y^3+x^2*y^2+x^3*y+x^4)
     sage: type(F)
-    <class 'sage.interfaces.maxima_abstract.MaximaElement'>
+    <class 'sage.interfaces.maxima.MaximaElement'>
 
 Note that Maxima objects can also be displayed using "ASCII art";
 to see a normal linear representation of any Maxima object x. Just
@@ -451,33 +451,21 @@
 
 import os, re, sys, subprocess
 import pexpect
-cygwin = os.uname()[0][:6]=="CYGWIN"
-
-from expect import Expect, ExpectElement, FunctionElement, ExpectFunction, gc_disabled, AsciiArtString
-from pexpect import EOF
+#cygwin = os.uname()[0][:6]=="CYGWIN"
 
 from random import randrange
 
+from sage.misc.misc import DOT_SAGE, SAGE_ROOT
+
 ##import sage.rings.all
 import sage.rings.complex_number
 
-from sage.misc.misc import verbose, DOT_SAGE, SAGE_ROOT
+from expect import Expect, ExpectElement, FunctionElement, ExpectFunction, gc_disabled, AsciiArtString
 
-from sage.misc.multireplace import multiple_replace
+from maxima_abstract import MaximaAbstract, MaximaAbstractFunction, MaximaAbstractElement, MaximaAbstractFunctionElement, MaximaAbstractElementFunction
 
-COMMANDS_CACHE = '%s/maxima_commandlist_cache.sobj'%DOT_SAGE
-
-import sage.server.support
-
-import maxima_abstract
-from maxima_abstract import MaximaFunctionElement, MaximaExpectFunction, MaximaElement, MaximaFunction, maxima_console
-
-# The Maxima "apropos" command, e.g., apropos(det) gives a list
-# of all identifiers that begin in a certain way.  This could
-# maybe be useful somehow... (?)  Also maxima has a lot for getting
-# documentation from the system -- this could also be useful.
-
-class Maxima(maxima_abstract.Maxima):
+# Thanks to the MRO for multiple inheritance used by the Sage's Python , this should work as expected
+class Maxima(MaximaAbstract, Expect):
     """
     Interface to the Maxima interpreter.
     """
@@ -493,7 +481,7 @@
 
         We make sure labels are turned off (see trac 6816)::
         
-            sage: 'nolabels:true' in maxima._Expect__init_code
+            sage: 'nolabels : true' in maxima._Expect__init_code
             True
         """
         # TODO: Input and output prompts in maxima can be changed by
@@ -509,8 +497,7 @@
         # this interface to preload commands, put them in
         # $DOT_SAGE/maxima/maxima-init.mac
         # (we use the "--userdir" option in maxima for this)
-        import sage.misc.misc
-        SAGE_MAXIMA_DIR = os.path.join(sage.misc.misc.DOT_SAGE,"maxima")
+        SAGE_MAXIMA_DIR = os.path.join(DOT_SAGE,"maxima")
         
         if not os.path.exists(STARTUP):
             raise RuntimeError, 'You must get the file local/bin/sage-maxima.lisp'
@@ -525,10 +512,9 @@
         # Many thanks to andrej.vodopivec@gmail.com and also
         # Robert Dodier for figuring this out!
         # See trac # 6818.  
-        init_code.append('nolabels:true')
-        
-        
-        
+        init_code.append('nolabels : true')
+                
+        MaximaAbstract.__init__(self,"maxima")
         Expect.__init__(self,
                         name = 'maxima',
                         prompt = '\(\%i[0-9]+\)',
@@ -552,15 +538,6 @@
 
 
 
-    def _function_class(self):
-        """
-        EXAMPLES::
-        
-            sage: maxima._function_class()
-            <class 'sage.interfaces.maxima_abstract.MaximaExpectFunction'>
-        """
-        return MaximaExpectFunction
-
     def _start(self):
         """
         Starts the Maxima interpreter.
@@ -751,7 +728,6 @@
             o = out[m.end()+1:-2]
         o = ''.join([x.strip() for x in o.split()])
         return o
-
         
     def _synchronize(self):
         """
@@ -795,6 +771,59 @@
             self._crash_msg()
             self.quit()
 
+    def _batch(self, s, batchload=True):
+        filename = '%s-%s'%(self._local_tmpfile(),randrange(2147483647))
+        F = open(filename, 'w')
+        F.write(s)
+        F.close()
+        if self.is_remote():
+            self._send_tmpfile_to_server(local_file=filename)
+            tmp_to_use = self._remote_tmpfile()
+        tmp_to_use = filename
+        
+        if batchload:
+            cmd = 'batchload("%s");'%tmp_to_use
+        else:
+            cmd = 'batch("%s");'%tmp_to_use
+
+        r = randrange(2147483647)
+        s = str(r+1)
+        cmd = "%s1+%s;\n"%(cmd,r)
+
+        self._sendline(cmd)
+        self._expect_expr(s)
+        out = self._before()
+        self._error_check(str, out)
+        os.unlink(filename)
+        return out
+
+    def _quit_string(self):
+        """
+        EXAMPLES::
+        
+            sage: maxima._quit_string()
+            'quit();'
+        """
+        return 'quit();'
+
+    def _crash_msg(self):
+        """
+        EXAMPLES::
+        
+            sage: maxima._crash_msg()
+            Maxima crashed -- automatically restarting.
+        """
+        print "Maxima crashed -- automatically restarting."
+
+    def _error_check(self, str, out):
+        r = self._error_re
+        m = r.search(out)
+        if not m is None:
+            self._error_msg(str, out)
+            
+    def _error_msg(self, str, out):
+        raise TypeError, "Error executing code in Maxima\nCODE:\n\t%s\nMaxima ERROR:\n\t%s"%(str, out.replace('-- an error.  To debug this try debugmode(true);',''))
+
     ###########################################
     # Direct access to underlying lisp interpreter. 
     ###########################################
@@ -817,127 +846,9 @@
         self._expect_expr('(%i)')
         return self._before()
 
-    ###########################################
-    # Interactive help
-    ###########################################
-    def _command_runner(self, command, s, redirect=True):
-        """
-        Run ``command`` in a new Maxima session and return its
-        output as an ``AsciiArtString``.
-        
-        If redirect is set to False, then the output of the command is not
-        returned as a string. Instead, it behaves like os.system. This is
-        used for interactive things like Maxima's demos. See maxima.demo?
-        
-        EXAMPLES::
-        
-            sage: maxima._command_runner('describe', 'gcd')
-            -- Function: gcd (<p_1>, <p_2>, <x_1>, ...)
-            ...
-        """
-        cmd = 'maxima --very-quiet -r "%s(%s);" '%(command, s)
-        if sage.server.support.EMBEDDED_MODE:
-            cmd += '< /dev/null'
-
-        if redirect:
-            p = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE,
-                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
-            res = p.stdout.read()
-            # ecl-10.2 : 3 lines
-            # ecl-10.4 : 5 lines
-            # ecl-11.1 : 4 lines fancy a tango?
-            # We now get 4 lines of commented verbosity
-            # every time Maxima starts, so we need to get rid of them
-            for _ in range(4):
-                res = res[res.find('\n')+1:]
-            return AsciiArtString(res)
-        else:
-            subprocess.Popen(cmd, shell=True)
-
-    def _object_class(self):
-        """
-        Return the Python class of Maxima elements.
-        
-        EXAMPLES::
-        
-            sage: maxima._object_class()
-            <class 'sage.interfaces.maxima_abstract.MaximaElement'>
-        """
-        return MaximaElement
-
-    def _function_element_class(self):
-        """      
-        EXAMPLES::
-        
-            sage: maxima._function_element_class()
-            <class 'sage.interfaces.maxima_abstract.MaximaFunctionElement'>
-        """
-        return MaximaFunctionElement
-
-    def function(self, args, defn, rep=None, latex=None):
-        """
-        Return the Maxima function with given arguments and definition.
-        
-        INPUT:
-        
-        
-        -  ``args`` - a string with variable names separated by
-           commas
-        
-        -  ``defn`` - a string (or Maxima expression) that
-           defines a function of the arguments in Maxima.
-        
-        -  ``rep`` - an optional string; if given, this is how
-           the function will print.
-        
-        
-        EXAMPLES::
-        
-            sage: f = maxima.function('x', 'sin(x)')
-            sage: f(3.2)
-            -.058374143427580...
-            sage: f = maxima.function('x,y', 'sin(x)+cos(y)')
-            sage: f(2,3.5)
-            sin(2)-.9364566872907963
-            sage: f
-            sin(x)+cos(y)
-        
-        ::
-        
-            sage: g = f.integrate('z')
-            sage: g
-            (cos(y)+sin(x))*z
-            sage: g(1,2,3)
-            3*(cos(2)+sin(1))
-        
-        The function definition can be a maxima object::
-        
-            sage: an_expr = maxima('sin(x)*gamma(x)')
-            sage: t = maxima.function('x', an_expr)
-            sage: t
-            gamma(x)*sin(x)
-            sage: t(2)
-             sin(2)
-            sage: float(t(2))
-            0.90929742682568171
-            sage: loads(t.dumps())
-            gamma(x)*sin(x)
-        """
-        name = self._next_var_name()
-        if isinstance(defn, MaximaElement):
-            defn = defn.str()
-        elif not isinstance(defn, str):
-            defn = str(defn)
-        if isinstance(args, MaximaElement):
-            args = args.str()
-        elif not isinstance(args, str):
-            args = str(args)
-        cmd = '%s(%s) := %s'%(name, args, defn)
-        maxima._eval_line(cmd)
-        if rep is None:
-            rep = defn
-        f = MaximaFunction(self, name, rep, args, latex)
-        return f
+    #####
+    #
+    #####
 
     def set(self, var, value):
         """
@@ -999,21 +910,48 @@
         """
         s = self._eval_line('%s;'%var)
         return s
-    
-    def version(self):
+
+    def _function_class(self):
         """
-        Return the version of Maxima that Sage includes.
+        EXAMPLES::
+        
+            sage: maxima._function_class()
+            <class 'sage.interfaces.maxima.MaximaFunction'>
+        """
+        return MaximaFunction
+
+    def _object_class(self):
+        """
+        Return the Python class of Maxima elements.
         
         EXAMPLES::
         
-            sage: maxima.version()
-            '5.23.2'
+            sage: maxima._object_class()
+            <class 'sage.interfaces.maxima.MaximaElement'>
         """
-        return maxima_version()
+        return MaximaElement
 
-##some helper functions to wrap tha calculus use of the maxima interface.
-##these routines expect arguments living in the symbolic ring and return something
-##that is hopefully coercible into the symbolic ring again.
+    def _function_element_class(self):
+        """      
+        EXAMPLES::
+        
+            sage: maxima._function_element_class()
+            <class 'sage.interfaces.maxima.MaximaFunctionElement'>
+        """
+        return MaximaFunctionElement
+
+    def _object_function_class(self):
+        """
+        EXAMPLES::
+        
+            sage: maxima._object_function_class()
+            <class 'sage.interfaces.maxima.MaximaElementFunction'>
+        """
+        return MaximaElementFunction
+
+    ##some helper functions to wrap tha calculus use of the maxima interface.
+    ##these routines expect arguments living in the symbolic ring and return something
+    ##that is hopefully coercible into the symbolic ring again.
 
     def sr_integral(self,*args):
         return args[0]._maxima_().integrate(*args[1:])
@@ -1029,28 +967,7 @@
 
     def sr_tlimit(self,ex,*args):
         return ex._maxima_().tlimit(*args)
-    
-##     def display2d(self, flag=True):
-##         """
-##         Set the flag that determines whether Maxima objects are
-##         printed using their 2-d ASCII art representation.  When the
-##         maxima interface starts the default is that objects are not
-##         represented in 2-d.
 
-##         INPUT:
-##             flag -- bool (default: True)
-
-##         EXAMPLES
-##             sage: maxima('1/2')
-##             1/2
-##             sage: maxima.display2d(True)
-##             sage: maxima('1/2')
-##                                            1
-##                                            -
-##                                            2
-##             sage: maxima.display2d(False)
-##         """
-##         self._display2d = bool(flag)
 
 def is_MaximaElement(x):
     """
@@ -1067,10 +984,65 @@
     """
     return isinstance(x, MaximaElement)
 
+# Thanks to the MRO for multiple inheritance used by the Sage's Python , this should work as expected
+class MaximaElement(MaximaAbstractElement, ExpectElement):
+    def __init__(self, parent, value, is_name=False, name=None):
+        ExpectElement.__init__(self, parent, value, is_name=False, name=None)
+
+    def display2d(self, onscreen=True):
+        """
+        EXAMPLES::
+        
+            sage: F = maxima('x^5 - y^5').factor()  
+            sage: F.display2d ()              
+                                   4      3    2  2    3      4
+                       - (y - x) (y  + x y  + x  y  + x  y + x )
+        """
+        self._check_valid()
+        P = self.parent()
+        with gc_disabled():
+            P._eval_line('display2d : true$')
+            s = P._eval_line('disp(%s)$'%self.name(), reformat=False)
+            P._eval_line('display2d : false$')
+            
+        s = s.strip('\r\n')
+
+        # if ever want to dedent, see
+        # http://mail.python.org/pipermail/python-list/2006-December/420033.html
+        if onscreen:
+            print s
+        else:
+            return s
+
+
+# Thanks to the MRO for multiple inheritance used by the Sage's Python , this should work as expected
+class MaximaFunctionElement(MaximaAbstractFunctionElement, FunctionElement):
+    pass
+#    def __init__(self, obj, name):
+#        MaximaAbstractFunctionElement.__init__(self, obj, name)
+#        FunctionElement.__init__(self, obj, name)
+
+
+# Thanks to the MRO for multiple inheritance used by the Sage's Python , this should work as expected
+class MaximaFunction(MaximaAbstractFunction, ExpectFunction):
+    pass
+#    def __init__(self, parent, name):
+#        MaximaAbstractFunction.__init__(self, parent, name)
+#        ExpectFunction.__init__(self, parent, name)
+
+
+# Thanks to the MRO for multiple inheritance used by the Sage's Python , this should work as expected
+class MaximaElementFunction(MaximaElement, MaximaAbstractElementFunction):
+    def __init__(self, parent, name, defn, args, latex):
+        MaximaElement.__init__(self, parent, name, is_name=True)
+        MaximaAbstractElementFunction.__init__(self, parent, name, defn, args, latex)
+
+
 # An instance
-maxima = Maxima(init_code = ['display2d:false; domain: complex; keepfloat: true'],
+maxima = Maxima(init_code = ['display2d : false; domain : complex; keepfloat : true'],
                 script_subdirectory=None)
 
+
 def reduce_load_Maxima():
     """
     EXAMPLES::
@@ -1081,16 +1053,8 @@
     """
     return maxima
 
-
-def maxima_version():
-    """
-    EXAMPLES::
-    
-        sage: from sage.interfaces.maxima import maxima_version
-        sage: maxima_version()
-        '5.23.2'
-    """
-    return os.popen('maxima --version').read().split()[-1]
+def reduce_load_Maxima_function(parent, defn, args, latex):
+    return parent.function(args, defn, defn, latex)
 
 def __doctest_cleanup():
     import sage.interfaces.quit
diff -r df3ffca81588 -r e20fb42bdea9 sage/interfaces/maxima_abstract.py
--- a/sage/interfaces/maxima_abstract.py	Tue Feb 15 17:14:05 2011 +0100
+++ b/sage/interfaces/maxima_abstract.py	Mon Feb 14 14:06:15 2011 +0100
@@ -28,408 +28,6 @@
 
 If the string "error" (case insensitive) occurs in the output of
 anything from Maxima, a RuntimeError exception is raised.
-
-EXAMPLES: We evaluate a very simple expression in Maxima.
-
-::
-
-    sage: maxima('3 * 5')
-    15
-
-We factor `x^5 - y^5` in Maxima in several different ways.
-The first way yields a Maxima object.
-
-::
-
-    sage: F = maxima.factor('x^5 - y^5')
-    sage: F
-    -(y-x)*(y^4+x*y^3+x^2*y^2+x^3*y+x^4)
-    sage: type(F)
-    <class 'sage.interfaces.maxima_abstract.MaximaElement'>
-
-Note that Maxima objects can also be displayed using "ASCII art";
-to see a normal linear representation of any Maxima object x. Just
-use the print command: use ``str(x)``.
-
-::
-
-    sage: print F
-                               4      3    2  2    3      4
-                   - (y - x) (y  + x y  + x  y  + x  y + x )
-
-You can always use ``repr(x)`` to obtain the linear
-representation of an object. This can be useful for moving maxima
-data to other systems.
-
-::
-
-    sage: repr(F)
-    '-(y-x)*(y^4+x*y^3+x^2*y^2+x^3*y+x^4)'
-    sage: F.str()
-    '-(y-x)*(y^4+x*y^3+x^2*y^2+x^3*y+x^4)'
-
-The ``maxima.eval`` command evaluates an expression in
-maxima and returns the result as a *string* not a maxima object.
-
-::
-
-    sage: print maxima.eval('factor(x^5 - y^5)')
-    -(y-x)*(y^4+x*y^3+x^2*y^2+x^3*y+x^4)
-
-We can create the polynomial `f` as a Maxima polynomial,
-then call the factor method on it. Notice that the notation
-``f.factor()`` is consistent with how the rest of Sage
-works.
-
-::
-
-    sage: f = maxima('x^5 - y^5')
-    sage: f^2
-    (x^5-y^5)^2
-    sage: f.factor()
-    -(y-x)*(y^4+x*y^3+x^2*y^2+x^3*y+x^4)
-
-Control-C interruption works well with the maxima interface,
-because of the excellent implementation of maxima. For example, try
-the following sum but with a much bigger range, and hit control-C.
-
-::
-
-    sage: maxima('sum(1/x^2, x, 1, 10)')
-    1968329/1270080
-
-Tutorial
---------
-
-We follow the tutorial at
-http://maxima.sourceforge.net/docs/intromax/.
-
-::
-
-    sage: maxima('1/100 + 1/101')
-    201/10100
-
-::
-
-    sage: a = maxima('(1 + sqrt(2))^5'); a
-    (sqrt(2)+1)^5
-    sage: a.expand()
-    3*2^(7/2)+5*sqrt(2)+41
-
-::
-
-    sage: a = maxima('(1 + sqrt(2))^5')
-    sage: float(a)                
-    82.012193308819747
-    sage: a.numer()
-    82.01219330881975
-
-::
-
-    sage: maxima.eval('fpprec : 100')
-    '100'
-    sage: a.bfloat()
-    8.20121933088197564152489730020812442785204843859314941221237124017312418754011041266612384955016056b1
-
-::
-
-    sage: maxima('100!')
-    93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
-
-::
-
-    sage: f = maxima('(x + 3*y + x^2*y)^3')
-    sage: f.expand()
-    x^6*y^3+9*x^4*y^3+27*x^2*y^3+27*y^3+3*x^5*y^2+18*x^3*y^2+27*x*y^2+3*x^4*y+9*x^2*y+x^3
-    sage: f.subst('x=5/z')
-    (5/z+25*y/z^2+3*y)^3
-    sage: g = f.subst('x=5/z')
-    sage: h = g.ratsimp(); h
-    (27*y^3*z^6+135*y^2*z^5+(675*y^3+225*y)*z^4+(2250*y^2+125)*z^3+(5625*y^3+1875*y)*z^2+9375*y^2*z+15625*y^3)/z^6
-    sage: h.factor()
-    (3*y*z^2+5*z+25*y)^3/z^6
-
-::
-
-    sage: eqn = maxima(['a+b*c=1', 'b-a*c=0', 'a+b=5'])
-    sage: s = eqn.solve('[a,b,c]'); s
-    [[a=(25*sqrt(79)*%i+25)/(6*sqrt(79)*%i-34),b=(5*sqrt(79)*%i+5)/(sqrt(79)*%i+11),c=(sqrt(79)*%i+1)/10],[a=(25*sqrt(79)*%i-25)/(6*sqrt(79)*%i+34),b=(5*sqrt(79)*%i-5)/(sqrt(79)*%i-11),c=-(sqrt(79)*%i-1)/10]]
-
-Here is an example of solving an algebraic equation::
-
-    sage: maxima('x^2+y^2=1').solve('y')
-    [y=-sqrt(1-x^2),y=sqrt(1-x^2)]
-    sage: maxima('x^2 + y^2 = (x^2 - y^2)/sqrt(x^2 + y^2)').solve('y')
-    [y=-sqrt((-y^2-x^2)*sqrt(y^2+x^2)+x^2),y=sqrt((-y^2-x^2)*sqrt(y^2+x^2)+x^2)]
-
-You can even nicely typeset the solution in latex::
-
-    sage: latex(s)
-    \left[ \left[ a={{25\,\sqrt{79}\,i+25}\over{6\,\sqrt{79}\,i-34}} ,   b={{5\,\sqrt{79}\,i+5}\over{\sqrt{79}\,i+11}} , c={{\sqrt{79}\,i+1  }\over{10}} \right]  , \left[ a={{25\,\sqrt{79}\,i-25}\over{6\,  \sqrt{79}\,i+34}} , b={{5\,\sqrt{79}\,i-5}\over{\sqrt{79}\,i-11}} ,   c=-{{\sqrt{79}\,i-1}\over{10}} \right]  \right] 
-
-To have the above appear onscreen via ``xdvi``, type
-``view(s)``. (TODO: For OS X should create pdf output
-and use preview instead?)
-
-::
-
-    sage: e = maxima('sin(u + v) * cos(u)^3'); e
-    cos(u)^3*sin(v+u)
-    sage: f = e.trigexpand(); f
-    cos(u)^3*(cos(u)*sin(v)+sin(u)*cos(v))
-    sage: f.trigreduce()
-    (sin(v+4*u)+sin(v-2*u))/8+(3*sin(v+2*u)+3*sin(v))/8
-    sage: w = maxima('3 + k*%i')
-    sage: f = w^2 + maxima('%e')^w
-    sage: f.realpart()
-    %e^3*cos(k)-k^2+9
-
-::
-
-    sage: f = maxima('x^3 * %e^(k*x) * sin(w*x)'); f
-    x^3*%e^(k*x)*sin(w*x)
-    sage: f.diff('x')
-    k*x^3*%e^(k*x)*sin(w*x)+3*x^2*%e^(k*x)*sin(w*x)+w*x^3*%e^(k*x)*cos(w*x)
-    sage: f.integrate('x')
-    (((k*w^6+3*k^3*w^4+3*k^5*w^2+k^7)*x^3+(3*w^6+3*k^2*w^4-3*k^4*w^2-3*k^6)*x^2+(-18*k*w^4-12*k^3*w^2+6*k^5)*x-6*w^4+36*k^2*w^2-6*k^4)*%e^(k*x)*sin(w*x)+((-w^7-3*k^2*w^5-3*k^4*w^3-k^6*w)*x^3+(6*k*w^5+12*k^3*w^3+6*k^5*w)*x^2+(6*w^5-12*k^2*w^3-18*k^4*w)*x-24*k*w^3+24*k^3*w)*%e^(k*x)*cos(w*x))/(w^8+4*k^2*w^6+6*k^4*w^4+4*k^6*w^2+k^8)
-
-::
-
-    sage: f = maxima('1/x^2')
-    sage: f.integrate('x', 1, 'inf')
-    1
-    sage: g = maxima('f/sinh(k*x)^4')
-    sage: g.taylor('x', 0, 3)
-    f/(k^4*x^4)-2*f/(3*k^2*x^2)+11*f/45-62*k^2*f*x^2/945
-
-::
-
-    sage: maxima.taylor('asin(x)','x',0, 10)
-    x+x^3/6+3*x^5/40+5*x^7/112+35*x^9/1152
-
-Examples involving matrices
----------------------------
-
-We illustrate computing with the matrix whose `i,j` entry
-is `i/j`, for `i,j=1,\ldots,4`.
-
-::
-
-    sage: f = maxima.eval('f[i,j] := i/j')
-    sage: A = maxima('genmatrix(f,4,4)'); A
-    matrix([1,1/2,1/3,1/4],[2,1,2/3,1/2],[3,3/2,1,3/4],[4,2,4/3,1])
-    sage: A.determinant()
-    0
-    sage: A.echelon()
-    matrix([1,1/2,1/3,1/4],[0,0,0,0],[0,0,0,0],[0,0,0,0])
-    sage: A.eigenvalues()
-    [[0,4],[3,1]]
-    sage: A.eigenvectors()
-    [[[0,4],[3,1]],[[[1,0,0,-4],[0,1,0,-2],[0,0,1,-4/3]],[[1,2,3,4]]]]
-
-We can also compute the echelon form in Sage::
-
-    sage: B = matrix(QQ, A)
-    sage: B.echelon_form()
-    [  1 1/2 1/3 1/4]
-    [  0   0   0   0]
-    [  0   0   0   0]
-    [  0   0   0   0]
-    sage: B.charpoly('x').factor()
-    (x - 4) * x^3
-
-Laplace Transforms
-------------------
-
-We illustrate Laplace transforms::
-
-    sage: _ = maxima.eval("f(t) := t*sin(t)")
-    sage: maxima("laplace(f(t),t,s)")
-    2*s/(s^2+1)^2
-
-::
-
-    sage: maxima("laplace(delta(t-3),t,s)") #Dirac delta function
-    %e^-(3*s)
-
-::
-
-    sage: _ = maxima.eval("f(t) := exp(t)*sin(t)")
-    sage: maxima("laplace(f(t),t,s)")
-    1/(s^2-2*s+2)
-
-::
-
-    sage: _ = maxima.eval("f(t) := t^5*exp(t)*sin(t)")
-    sage: maxima("laplace(f(t),t,s)")
-    360*(2*s-2)/(s^2-2*s+2)^4-480*(2*s-2)^3/(s^2-2*s+2)^5+120*(2*s-2)^5/(s^2-2*s+2)^6
-    sage: print maxima("laplace(f(t),t,s)")
-                                             3                 5
-               360 (2 s - 2)    480 (2 s - 2)     120 (2 s - 2)
-              --------------- - --------------- + ---------------
-                2           4     2           5     2           6
-              (s  - 2 s + 2)    (s  - 2 s + 2)    (s  - 2 s + 2)
-
-::
-
-    sage: maxima("laplace(diff(x(t),t),t,s)")
-    s*'laplace(x(t),t,s)-x(0)
-
-::
-
-    sage: maxima("laplace(diff(x(t),t,2),t,s)")
-    -?%at('diff(x(t),t,1),t=0)+s^2*'laplace(x(t),t,s)-x(0)*s
-
-It is difficult to read some of these without the 2d
-representation::
-
-    sage: print maxima("laplace(diff(x(t),t,2),t,s)")
-                         !
-                d        !         2
-              - -- (x(t))!      + s  laplace(x(t), t, s) - x(0) s
-                dt       !
-                         !t = 0
-
-Even better, use
-``view(maxima("laplace(diff(x(t),t,2),t,s)"))`` to see
-a typeset version.
-
-Continued Fractions
--------------------
-
-A continued fraction `a + 1/(b + 1/(c + \cdots))` is
-represented in maxima by the list `[a, b, c, \ldots]`.
-
-::
-
-    sage: maxima("cf((1 + sqrt(5))/2)")
-    [1,1,1,1,2]
-    sage: maxima("cf ((1 + sqrt(341))/2)")
-    [9,1,2,1,2,1,17,1,2,1,2,1,17,1,2,1,2,1,17,2]
-
-Special examples
-----------------
-
-In this section we illustrate calculations that would be awkward to
-do (as far as I know) in non-symbolic computer algebra systems like
-MAGMA or GAP.
-
-We compute the gcd of `2x^{n+4} - x^{n+2}` and
-`4x^{n+1} + 3x^n` for arbitrary `n`.
-
-::
-
-    sage: f = maxima('2*x^(n+4) - x^(n+2)')
-    sage: g = maxima('4*x^(n+1) + 3*x^n')
-    sage: f.gcd(g)
-    x^n
-
-You can plot 3d graphs (via gnuplot)::
-
-    sage: maxima('plot3d(x^2-y^2, [x,-2,2], [y,-2,2], [grid,12,12])')  # not tested
-    [displays a 3 dimensional graph]
-
-You can formally evaluate sums (note the ``nusum``
-command)::
-
-    sage: S = maxima('nusum(exp(1+2*i/n),i,1,n)')
-    sage: print S
-                            2/n + 3                   2/n + 1
-                          %e                        %e
-                   ----------------------- - -----------------------
-                      1/n         1/n           1/n         1/n
-                   (%e    - 1) (%e    + 1)   (%e    - 1) (%e    + 1)
-
-We formally compute the limit as `n\to\infty` of
-`2S/n` as follows::
-
-    sage: T = S*maxima('2/n')
-    sage: T.tlimit('n','inf')
-    %e^3-%e
-
-Miscellaneous
--------------
-
-Obtaining digits of `\pi`::
-
-    sage: maxima.eval('fpprec : 100')
-    '100'
-    sage: maxima(pi).bfloat()
-    3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068b0
-
-Defining functions in maxima::
-
-    sage: maxima.eval('fun[a] := a^2')
-    'fun[a]:=a^2'
-    sage: maxima('fun[10]')
-    100
-
-Interactivity
--------------
-
-Unfortunately maxima doesn't seem to have a non-interactive mode,
-which is needed for the Sage interface. If any Sage call leads to
-maxima interactively answering questions, then the questions can't be
-answered and the maxima session may hang. See the discussion at
-http://www.ma.utexas.edu/pipermail/maxima/2005/011061.html for some
-ideas about how to fix this problem. An example that illustrates this
-problem is ``maxima.eval('integrate (exp(a*x), x, 0, inf)')``.
-
-Latex Output
-------------
-
-To TeX a maxima object do this::
-
-    sage: latex(maxima('sin(u) + sinh(v^2)'))
-    \sinh v^2+\sin u
-
-Here's another example::
-
-    sage: g = maxima('exp(3*%i*x)/(6*%i) + exp(%i*x)/(2*%i) + c')
-    sage: latex(g)
-    -{{i\,e^{3\,i\,x}}\over{6}}-{{i\,e^{i\,x}}\over{2}}+c
-
-Long Input
-----------
-
-The MAXIMA interface reads in even very long input (using files) in
-a robust manner, as long as you are creating a new object.
-
-.. note::
-
-   Using ``maxima.eval`` for long input is much less robust, and is
-   not recommended.
-
-::
-
-    sage: t = '"%s"'%10^10000   # ten thousand character string.
-    sage: a = maxima(t)
-
-TESTS: This working tests that a subtle bug has been fixed::
-
-    sage: f = maxima.function('x','gamma(x)')
-    sage: g = f(1/7)
-    sage: g
-    gamma(1/7)
-    sage: del f
-    sage: maxima(sin(x))
-    sin(x)
-
-This tests to make sure we handle the case where Maxima asks if an
-expression is positive or zero.
-
-::
-
-    sage: var('Ax,Bx,By')
-    (Ax, Bx, By)
-    sage: t = -Ax*sin(sqrt(Ax^2)/2)/(sqrt(Ax^2)*sqrt(By^2 + Bx^2))
-    sage: t.limit(Ax=0, dir='+')
-    0
-
-A long complicated input expression::
-
-    sage: maxima._eval_line('((((((((((0) + ((1) / ((n0) ^ (0)))) + ((1) / ((n1) ^ (1)))) + ((1) / ((n2) ^ (2)))) + ((1) / ((n3) ^ (3)))) + ((1) / ((n4) ^ (4)))) + ((1) / ((n5) ^ (5)))) + ((1) / ((n6) ^ (6)))) + ((1) / ((n7) ^ (7)))) + ((1) / ((n8) ^ (8)))) + ((1) / ((n9) ^ (9)));')
-    '1/n9^9+1/n8^8+1/n7^7+1/n6^6+1/n5^5+1/n4^4+1/n3^3+1/n2^2+1/n1+1'
 """
 
 #*****************************************************************************
@@ -447,158 +45,34 @@
 #                  http://www.gnu.org/licenses/
 #*****************************************************************************
 
-from __future__ import with_statement
+import os, re, sys, subprocess
 
-import os, re, sys, subprocess
-import pexpect
-cygwin = os.uname()[0][:6]=="CYGWIN"
+from sage.misc.misc import DOT_SAGE
+COMMANDS_CACHE = '%s/maxima_commandlist_cache.sobj'%DOT_SAGE
 
-from expect import Expect, ExpectElement, FunctionElement, ExpectFunction, gc_disabled, AsciiArtString
-from pexpect import EOF
+from sage.misc.multireplace import multiple_replace
 
-from random import randrange
+import sage.server.support
 
 ##import sage.rings.all
 import sage.rings.complex_number
 
-from sage.misc.misc import verbose, DOT_SAGE, SAGE_ROOT
-
-from sage.misc.multireplace import multiple_replace
-
-COMMANDS_CACHE = '%s/maxima_commandlist_cache.sobj'%DOT_SAGE
-
-import sage.server.support
+from interface import Interface, InterfaceElement, InterfaceFunctionElement, InterfaceFunction, AsciiArtString
 
 # The Maxima "apropos" command, e.g., apropos(det) gives a list
 # of all identifiers that begin in a certain way.  This could
 # maybe be useful somehow... (?)  Also maxima has a lot for getting
 # documentation from the system -- this could also be useful.
 
-class Maxima(Expect):
+class MaximaAbstract(Interface):
     """
     Interface to the Maxima interpreter.
     """
-    def __init__(self, script_subdirectory=None, logfile=None, server=None,
-                 init_code = None):
+    def __init__(self, name):
         """
-        Create an instance of the Maxima interpreter.
-
-        TESTS::
-        
-            sage: maxima == loads(dumps(maxima))
-            True
-
-        We make sure labels are turned off (see trac 6816)::
-        
-            sage: 'nolabels:true' in maxima._Expect__init_code
-            True
+        Create an instance of an abstract interface to Maxima.
         """
-        # TODO: Input and output prompts in maxima can be changed by
-        # setting inchar and outchar..
-        eval_using_file_cutoff = 256
-        self.__eval_using_file_cutoff = eval_using_file_cutoff
-        STARTUP = '%s/local/bin/sage-maxima.lisp'%SAGE_ROOT
-        
-        # We set maxima's configuration directory to $DOT_SAGE/maxima
-        # This avoids that sage's maxima inadvertently loads
-        # ~/.maxima/maxima-init.mac
-        # If you absolutely want maxima instances that are started by
-        # this interface to preload commands, put them in
-        # $DOT_SAGE/maxima/maxima-init.mac
-        # (we use the "--userdir" option in maxima for this)
-        import sage.misc.misc
-        SAGE_MAXIMA_DIR = os.path.join(sage.misc.misc.DOT_SAGE,"maxima")
-        
-        if not os.path.exists(STARTUP):
-            raise RuntimeError, 'You must get the file local/bin/sage-maxima.lisp'
-        if init_code is None:
-            # display2d -- no ascii art output
-            # keepfloat -- don't automatically convert floats to rationals
-            init_code = ['display2d : false', 'keepfloat : true']
-            
-        # Turn off the prompt labels, since computing them *very
-        # dramatically* slows down the maxima interpret after a while.
-        # See the function makelabel in suprv1.lisp.
-        # Many thanks to andrej.vodopivec@gmail.com and also
-        # Robert Dodier for figuring this out!
-        # See trac # 6818.  
-        init_code.append('nolabels:true')
-        
-        Expect.__init__(self,
-                        name = 'maxima',
-                        prompt = '\(\%i[0-9]+\)',
-                        command = 'maxima-noreadline --userdir="%s" -p "%s"'%(SAGE_MAXIMA_DIR,STARTUP), 
-                        maxread = 10000, 
-                        script_subdirectory = script_subdirectory,
-                        restart_on_ctrlc = False,
-                        verbose_start = False,
-                        init_code = init_code,
-                        logfile = logfile,
-                        eval_using_file_cutoff=eval_using_file_cutoff)
-        self._display_prompt = '<sage-display>'  # must match what is in the file local/bin/sage-maxima.lisp!!
-        self._output_prompt_re = re.compile('\(\%o[0-9]+\)')
-        self._ask = ['zero or nonzero?', 'an integer?', 'positive, negative, or zero?', 
-                     'positive or negative?', 'positive or zero?']
-        self._prompt_wait = [self._prompt] + [re.compile(x) for x in self._ask] + \
-                            ['Break [0-9]+'] #note that you might need to change _expect_expr if you
-                                             #change this
-        self._error_re = re.compile('(Principal Value|debugmode|incorrect syntax|Maxima encountered a Lisp error)')
-        self._display2d = False
-
-    def _quit_string(self):
-        """
-        EXAMPLES::
-        
-            sage: maxima._quit_string()
-            'quit();'
-        """
-        return 'quit();'
-
-    def _crash_msg(self):
-        """
-        EXAMPLES::
-        
-            sage: maxima._crash_msg()
-            Maxima crashed -- automatically restarting.
-        """
-        print "Maxima crashed -- automatically restarting."
-
-
-    def _batch(self, s, batchload=True):
-        filename = '%s-%s'%(self._local_tmpfile(),randrange(2147483647))
-        F = open(filename, 'w')
-        F.write(s)
-        F.close()
-        if self.is_remote():
-            self._send_tmpfile_to_server(local_file=filename)
-            tmp_to_use = self._remote_tmpfile()
-        tmp_to_use = filename
-        
-        if batchload:
-            cmd = 'batchload("%s");'%tmp_to_use
-        else:
-            cmd = 'batch("%s");'%tmp_to_use
-
-        r = randrange(2147483647)
-        s = str(r+1)
-        cmd = "%s1+%s;\n"%(cmd,r)
-
-        self._sendline(cmd)
-        self._expect_expr(s)
-        out = self._before()
-        self._error_check(str, out)
-        os.unlink(filename)
-        return out
-
-    def _error_check(self, str, out):
-        r = self._error_re
-        m = r.search(out)
-        if not m is None:
-            self._error_msg(str, out)
-            
-    def _error_msg(self, str, out):
-        raise TypeError, "Error executing code in Maxima\nCODE:\n\t%s\nMaxima ERROR:\n\t%s"%(str, out.replace('-- an error.  To debug this try debugmode(true);',''))
-
+        Interface.__init__(self,name)
 
     ###########################################
     # System -- change directory, etc
@@ -616,7 +90,39 @@
     ###########################################
     # Interactive help
     ###########################################
+    def _command_runner(self, command, s, redirect=True):
+        """
+        Run ``command`` in a new Maxima session and return its
+        output as an ``AsciiArtString``.
+        
+        If redirect is set to False, then the output of the command is not
+        returned as a string. Instead, it behaves like os.system. This is
+        used for interactive things like Maxima's demos. See maxima.demo?
+        
+        EXAMPLES::
+        
+            sage: maxima._command_runner('describe', 'gcd')
+            -- Function: gcd (<p_1>, <p_2>, <x_1>, ...)
+            ...
+        """
+        cmd = 'maxima --very-quiet -r "%s(%s);" '%(command, s)
+        if sage.server.support.EMBEDDED_MODE:
+            cmd += '< /dev/null'
 
+        if redirect:
+            p = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE,
+                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+            res = p.stdout.read()
+            # ecl-10.2 : 3 lines
+            # ecl-10.4 : 5 lines
+            # ecl-11.1 : 4 lines fancy a tango?
+            # We now get 4 lines of commented verbosity
+            # every time Maxima starts, so we need to get rid of them
+            for _ in range(4):
+                res = res[res.find('\n')+1:]
+            return AsciiArtString(res)
+        else:
+            subprocess.Popen(cmd, shell=True)
 
     def help(self, s):
         """
@@ -736,6 +242,69 @@
             sage.misc.persist.save(v, COMMANDS_CACHE)
             return v
 
+    def console(self):
+        r"""
+        Start the interactive Maxima console. This is a completely separate
+        maxima session from this interface. To interact with this session,
+        you should instead use ``maxima.interact()``.
+        
+        EXAMPLES::
+        
+            sage: maxima.console()             # not tested (since we can't)
+            Maxima 5.13.0 http://maxima.sourceforge.net
+            Using Lisp CLISP 2.41 (2006-10-13)
+            Distributed under the GNU Public License. See the file COPYING.
+            Dedicated to the memory of William Schelter.
+            This is a development version of Maxima. The function bug_report()
+            provides bug reporting information.
+            (%i1)
+        
+        ::
+        
+            sage: maxima.interact()     # this is not tested either
+              --> Switching to Maxima <-- 
+            maxima: 2+2
+            4
+            maxima: 
+              --> Exiting back to Sage <--
+        """
+        maxima_console()
+
+    def cputime(self, t=None):
+        r"""
+        Returns the amount of CPU time that this Maxima session has used.
+        If \var{t} is not None, then it returns the difference between
+        the current CPU time and \var{t}.
+        
+        EXAMPLES:
+            sage: t = maxima.cputime()
+            sage: _ = maxima.de_solve('diff(y,x,2) + 3*x = y', ['x','y'], [1,1,1])
+            sage: maxima.cputime(t) # output random
+            0.568913
+        """
+        if t:
+            return float(self.eval('elapsed_run_time()')) - t
+        else:
+            return float(self.eval('elapsed_run_time()'))
+
+    def version(self):
+        """
+        Return the version of Maxima that Sage includes.
+        
+        EXAMPLES::
+        
+            sage: maxima.version()
+            '5.23.2'
+        """
+        return maxima_version()
+
+    ####
+    # Overriding default values
+    ###
+
+    def _assign_symbol(self):
+        return ":"
+
     def _true_symbol(self):
         """
         Return the true symbol in Maxima.
@@ -786,52 +355,117 @@
         """
         return '#'
 
-    def console(self):
-        r"""
-        Start the interactive Maxima console. This is a completely separate
-        maxima session from this interface. To interact with this session,
-        you should instead use ``maxima.interact()``.
+    def _function_class(self):
+        """
+        EXAMPLES::
+        
+            sage: maxima._function_class()
+            <class 'sage.interfaces.maxima.MaximaFunction'>
+        """
+        return MaximaAbstractFunction
+
+    def _object_class(self):
+        """
+        Return the Python class of Maxima elements.
         
         EXAMPLES::
         
-            sage: maxima.console()             # not tested (since we can't)
-            Maxima 5.13.0 http://maxima.sourceforge.net
-            Using Lisp CLISP 2.41 (2006-10-13)
-            Distributed under the GNU Public License. See the file COPYING.
-            Dedicated to the memory of William Schelter.
-            This is a development version of Maxima. The function bug_report()
-            provides bug reporting information.
-            (%i1)
+            sage: maxima._object_class()
+            <class 'sage.interfaces.maxima.MaximaElement'>
+        """
+        return MaximaAbstractElement
+
+    def _function_element_class(self):
+        """      
+        EXAMPLES::
+        
+            sage: maxima._function_element_class()
+            <class 'sage.interfaces.maxima.MaximaFunctionElement'>
+        """
+        return MaximaAbstractFunctionElement
+
+    def _object_function_class(self):
+        """
+        EXAMPLES::
+        
+            sage: maxima._object_function_class()
+            <class 'sage.interfaces.maxima.MaximaElementFunction'>
+        """
+        return MaximaAbstractElementFunction
+
+    ####
+    #
+    ####
+
+    def function(self, args, defn, rep=None, latex=None):
+        """
+        Return the Maxima function with given arguments and definition.
+        
+        INPUT:
+        
+        
+        -  ``args`` - a string with variable names separated by
+           commas
+        
+        -  ``defn`` - a string (or Maxima expression) that
+           defines a function of the arguments in Maxima.
+        
+        -  ``rep`` - an optional string; if given, this is how
+           the function will print.
+        
+        
+        EXAMPLES::
+        
+            sage: f = maxima.function('x', 'sin(x)')
+            sage: f(3.2)
+            -.058374143427580...
+            sage: f = maxima.function('x,y', 'sin(x)+cos(y)')
+            sage: f(2,3.5)
+            sin(2)-.9364566872907963
+            sage: f
+            sin(x)+cos(y)
         
         ::
         
-            sage: maxima.interact()     # this is not tested either
-              --> Switching to Maxima <-- 
-            maxima: 2+2
-            4
-            maxima: 
-              --> Exiting back to Sage <--
+            sage: g = f.integrate('z')
+            sage: g
+            (cos(y)+sin(x))*z
+            sage: g(1,2,3)
+            3*(cos(2)+sin(1))
+        
+        The function definition can be a maxima object::
+        
+            sage: an_expr = maxima('sin(x)*gamma(x)')
+            sage: t = maxima.function('x', an_expr)
+            sage: t
+            gamma(x)*sin(x)
+            sage: t(2)
+             sin(2)
+            sage: float(t(2))
+            0.90929742682568171
+            sage: loads(t.dumps())
+            gamma(x)*sin(x)
         """
-        maxima_console()
+        name = self._next_var_name()
+        if isinstance(defn, MaximaAbstractElement):
+            defn = defn.str()
+        elif not isinstance(defn, str):
+            defn = str(defn)
+        if isinstance(args, MaximaAbstractElement):
+            args = args.str()
+        elif not isinstance(args, str):
+            args = str(args)
+        cmd = '%s(%s) := %s'%(name, args, defn)
+        self._eval_line(cmd)
+        if rep is None:
+            rep = defn
+        f = self._object_function_class()(self, name, rep, args, latex)
+        return f
 
-    def cputime(self, t=None):
-        r"""
-        Returns the amount of CPU time that this Maxima session has used.
-        If \var{t} is not None, then it returns the difference between
-        the current CPU time and \var{t}.
-        
-        EXAMPLES:
-            sage: t = maxima.cputime()
-            sage: _ = maxima.de_solve('diff(y,x,2) + 3*x = y', ['x','y'], [1,1,1])
-            sage: maxima.cputime(t) # output random
-            0.568913
-        """
-        if t:
-            return float(self.eval('elapsed_run_time()')) - t
-        else:
-            return float(self.eval('elapsed_run_time()'))
-
-
+    #####
+    # Maxima functions
+    #####
+   
 ##     def display2d(self, flag=True):
 ##         """
 ##         Set the flag that determines whether Maxima objects are
@@ -1248,7 +882,7 @@
             self('plot2d('+cmd+','+options+')')
     
 
-class MaximaElement(ExpectElement):
+class MaximaAbstractElement(InterfaceElement):
     def __str__(self):
         """
         Printing an object explicitly gives ASCII art:
@@ -1469,7 +1103,7 @@
             sage: a = maxima('sqrt(2)').numer(); a
             1.41421356237309...
             sage: type(a)
-            <class 'sage.interfaces.maxima_abstract.MaximaElement'>
+            <class 'sage.interfaces.maxima.MaximaElement'>
         """
         return self.comma('numer')
 
@@ -1503,31 +1137,6 @@
         self.__repr = r
         return r
 
-    def display2d(self, onscreen=True):
-        """
-        EXAMPLES::
-        
-            sage: F = maxima('x^5 - y^5').factor()  
-            sage: F.display2d ()              
-                                   4      3    2  2    3      4
-                       - (y - x) (y  + x y  + x  y  + x  y + x )
-        """
-        self._check_valid()
-        P = self.parent()
-        with gc_disabled():
-            P._eval_line('display2d : true$')
-            s = P._eval_line('disp(%s)$'%self.name(), reformat=False)
-            P._eval_line('display2d: false$')
-            
-        s = s.strip('\r\n')
-
-        # if ever want to dedent, see
-        # http://mail.python.org/pipermail/python-list/2006-December/420033.html
-        if onscreen:
-            print s
-        else:
-            return s
-
     def diff(self, var='x', n=1):
         """
         Return the n-th derivative of self.
@@ -1562,7 +1171,7 @@
             sage: f.diff('y')                                
             34*y
         """
-        return ExpectElement.__getattr__(self, 'diff')(var, n)
+        return InterfaceElement.__getattr__(self, 'diff')(var, n)
 
     derivative = diff
 
@@ -1675,7 +1284,7 @@
             sage: f.numer()
             1.46265174590718...
         """
-        I = ExpectElement.__getattr__(self, 'integrate')
+        I = InterfaceElement.__getattr__(self, 'integrate')
         if min is None:
             return I(var)
         else:
@@ -1757,7 +1366,7 @@
         if n < 0 or n >= len(self):
             raise IndexError, "n = (%s) must be between %s and %s"%(n, 0, len(self)-1)
         # If you change the n+1 to n below, better change __iter__ as well.
-        return ExpectElement.__getitem__(self, n+1)
+        return InterfaceElement.__getitem__(self, n+1)
 
     def __iter__(self):
         """
@@ -1940,7 +1549,7 @@
         """
         P = self._check_valid()
 
-        if isinstance(right, MaximaFunction):
+        if isinstance(right, P._object_function_class()):
             fself = P.function('', repr(self))
             return fself._operation(operation, right)
 
@@ -1950,33 +1559,15 @@
             raise TypeError, msg
 
 
-        
-class MaximaFunctionElement(FunctionElement):
-    def _sage_doc_(self):
-        """
-        EXAMPLES::
-        
-            sage: m = maxima(4)
-            sage: m.gcd._sage_doc_()
-            -- Function: gcd (<p_1>, <p_2>, <x_1>, ...)
-            ...
-        """
-        return self._obj.parent().help(self._name)
+class MaximaAbstractFunctionElement(InterfaceFunctionElement):
+    pass
 
-class MaximaExpectFunction(ExpectFunction):
-    def _sage_doc_(self):
-        """
-        EXAMPLES::
-        
-            sage: maxima.gcd._sage_doc_()
-            -- Function: gcd (<p_1>, <p_2>, <x_1>, ...)
-            ...
-        """
-        M = self._parent
-        return M.help(self._name)
 
+class MaximaAbstractFunction(InterfaceFunction):
+    pass
 
-class MaximaFunction(MaximaElement):
+
+class MaximaAbstractElementFunction(MaximaAbstractElement):
     def __init__(self, parent, name, defn, args, latex):
         """
         EXAMPLES::
@@ -1985,7 +1576,7 @@
             sage: f == loads(dumps(f))
             True
         """
-        MaximaElement.__init__(self, parent, name, is_name=True)
+        MaximaAbstractElement.__init__(self, parent, name, is_name=True)
         self.__defn = defn
         self.__args = args
         self.__latex = latex
@@ -1996,10 +1587,10 @@
         
             sage: f = maxima.function('x,y','sin(x+y)')
             sage: f.__reduce__()
-            (<function reduce_load_Maxima_function at 0x...>,
+            (<function reduce_load_MaximaAbstract_function at 0x...>,
              (Maxima, 'sin(x+y)', 'x,y', None))
         """
-        return reduce_load_Maxima_function, (self.parent(), self.__defn, self.__args, self.__latex)
+        return reduce_load_MaximaAbstract_function, (self.parent(), self.__defn, self.__args, self.__latex)
         
     def __call__(self, *x):
         """
@@ -2127,7 +1718,7 @@
             1/sin(y+x)
         """
         P = self._check_valid()
-        if isinstance(f, MaximaFunction):
+        if isinstance(f, P._object_function_class()):
             tmp = list(sorted(set(self.arguments() + f.arguments())))
             args = ','.join(tmp)
             defn = "(%s)%s(%s)"%(self.definition(), operation, f.definition())
@@ -2298,18 +1889,26 @@
         return self._operation("^", f)
 
 
-def reduce_load_Maxima_function(parent, defn, args, latex):
+def reduce_load_MaximaAbstract_function(parent, defn, args, latex):
     return parent.function(args, defn, defn, latex)
     
+def maxima_version():
+    """
+    EXAMPLES::
+    
+        sage: from sage.interfaces.maxima_abstract import maxima_version
+        sage: maxima_version()
+        '5.23.2'
+    """
+    return os.popen('maxima --version').read().split()[-1]
 
-import os
 def maxima_console():
     """
     Spawn a new Maxima command-line session.
     
     EXAMPLES::
     
-        sage: from sage.interfaces.maxima import maxima_console
+        sage: from sage.interfaces.maxima_abstract import maxima_console
         sage: maxima_console()                    # not tested
         Maxima 5.23.2 http://maxima.sourceforge.net
         ...
diff -r df3ffca81588 -r e20fb42bdea9 sage/interfaces/maxima_lib.py
--- a/sage/interfaces/maxima_lib.py	Tue Feb 15 17:14:05 2011 +0100
+++ b/sage/interfaces/maxima_lib.py	Mon Feb 14 14:06:15 2011 +0100
@@ -28,408 +28,6 @@
 
 If the string "error" (case insensitive) occurs in the output of
 anything from Maxima, a RuntimeError exception is raised.
-
-EXAMPLES: We evaluate a very simple expression in Maxima.
-
-::
-
-    sage: maxima('3 * 5')
-    15
-
-We factor `x^5 - y^5` in Maxima in several different ways.
-The first way yields a Maxima object.
-
-::
-
-    sage: F = maxima.factor('x^5 - y^5')
-    sage: F
-    -(y-x)*(y^4+x*y^3+x^2*y^2+x^3*y+x^4)
-    sage: type(F)
-    <class 'sage.interfaces.maxima_abstract.MaximaElement'>
-
-Note that Maxima objects can also be displayed using "ASCII art";
-to see a normal linear representation of any Maxima object x. Just
-use the print command: use ``str(x)``.
-
-::
-
-    sage: print F
-                               4      3    2  2    3      4
-                   - (y - x) (y  + x y  + x  y  + x  y + x )
-
-You can always use ``repr(x)`` to obtain the linear
-representation of an object. This can be useful for moving maxima
-data to other systems.
-
-::
-
-    sage: repr(F)
-    '-(y-x)*(y^4+x*y^3+x^2*y^2+x^3*y+x^4)'
-    sage: F.str()
-    '-(y-x)*(y^4+x*y^3+x^2*y^2+x^3*y+x^4)'
-
-The ``maxima.eval`` command evaluates an expression in
-maxima and returns the result as a *string* not a maxima object.
-
-::
-
-    sage: print maxima.eval('factor(x^5 - y^5)')
-    -(y-x)*(y^4+x*y^3+x^2*y^2+x^3*y+x^4)
-
-We can create the polynomial `f` as a Maxima polynomial,
-then call the factor method on it. Notice that the notation
-``f.factor()`` is consistent with how the rest of Sage
-works.
-
-::
-
-    sage: f = maxima('x^5 - y^5')
-    sage: f^2
-    (x^5-y^5)^2
-    sage: f.factor()
-    -(y-x)*(y^4+x*y^3+x^2*y^2+x^3*y+x^4)
-
-Control-C interruption works well with the maxima interface,
-because of the excellent implementation of maxima. For example, try
-the following sum but with a much bigger range, and hit control-C.
-
-::
-
-    sage: maxima('sum(1/x^2, x, 1, 10)')
-    1968329/1270080
-
-Tutorial
---------
-
-We follow the tutorial at
-http://maxima.sourceforge.net/docs/intromax/.
-
-::
-
-    sage: maxima('1/100 + 1/101')
-    201/10100
-
-::
-
-    sage: a = maxima('(1 + sqrt(2))^5'); a
-    (sqrt(2)+1)^5
-    sage: a.expand()
-    3*2^(7/2)+5*sqrt(2)+41
-
-::
-
-    sage: a = maxima('(1 + sqrt(2))^5')
-    sage: float(a)                
-    82.012193308819747
-    sage: a.numer()
-    82.01219330881975
-
-::
-
-    sage: maxima.eval('fpprec : 100')
-    '100'
-    sage: a.bfloat()
-    8.20121933088197564152489730020812442785204843859314941221237124017312418754011041266612384955016056b1
-
-::
-
-    sage: maxima('100!')
-    93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
-
-::
-
-    sage: f = maxima('(x + 3*y + x^2*y)^3')
-    sage: f.expand()
-    x^6*y^3+9*x^4*y^3+27*x^2*y^3+27*y^3+3*x^5*y^2+18*x^3*y^2+27*x*y^2+3*x^4*y+9*x^2*y+x^3
-    sage: f.subst('x=5/z')
-    (5/z+25*y/z^2+3*y)^3
-    sage: g = f.subst('x=5/z')
-    sage: h = g.ratsimp(); h
-    (27*y^3*z^6+135*y^2*z^5+(675*y^3+225*y)*z^4+(2250*y^2+125)*z^3+(5625*y^3+1875*y)*z^2+9375*y^2*z+15625*y^3)/z^6
-    sage: h.factor()
-    (3*y*z^2+5*z+25*y)^3/z^6
-
-::
-
-    sage: eqn = maxima(['a+b*c=1', 'b-a*c=0', 'a+b=5'])
-    sage: s = eqn.solve('[a,b,c]'); s
-    [[a=(25*sqrt(79)*%i+25)/(6*sqrt(79)*%i-34),b=(5*sqrt(79)*%i+5)/(sqrt(79)*%i+11),c=(sqrt(79)*%i+1)/10],[a=(25*sqrt(79)*%i-25)/(6*sqrt(79)*%i+34),b=(5*sqrt(79)*%i-5)/(sqrt(79)*%i-11),c=-(sqrt(79)*%i-1)/10]]
-
-Here is an example of solving an algebraic equation::
-
-    sage: maxima('x^2+y^2=1').solve('y')
-    [y=-sqrt(1-x^2),y=sqrt(1-x^2)]
-    sage: maxima('x^2 + y^2 = (x^2 - y^2)/sqrt(x^2 + y^2)').solve('y')
-    [y=-sqrt((-y^2-x^2)*sqrt(y^2+x^2)+x^2),y=sqrt((-y^2-x^2)*sqrt(y^2+x^2)+x^2)]
-
-You can even nicely typeset the solution in latex::
-
-    sage: latex(s)
-    \left[ \left[ a={{25\,\sqrt{79}\,i+25}\over{6\,\sqrt{79}\,i-34}} ,   b={{5\,\sqrt{79}\,i+5}\over{\sqrt{79}\,i+11}} , c={{\sqrt{79}\,i+1  }\over{10}} \right]  , \left[ a={{25\,\sqrt{79}\,i-25}\over{6\,  \sqrt{79}\,i+34}} , b={{5\,\sqrt{79}\,i-5}\over{\sqrt{79}\,i-11}} ,   c=-{{\sqrt{79}\,i-1}\over{10}} \right]  \right] 
-
-To have the above appear onscreen via ``xdvi``, type
-``view(s)``. (TODO: For OS X should create pdf output
-and use preview instead?)
-
-::
-
-    sage: e = maxima('sin(u + v) * cos(u)^3'); e
-    cos(u)^3*sin(v+u)
-    sage: f = e.trigexpand(); f
-    cos(u)^3*(cos(u)*sin(v)+sin(u)*cos(v))
-    sage: f.trigreduce()
-    (sin(v+4*u)+sin(v-2*u))/8+(3*sin(v+2*u)+3*sin(v))/8
-    sage: w = maxima('3 + k*%i')
-    sage: f = w^2 + maxima('%e')^w
-    sage: f.realpart()
-    %e^3*cos(k)-k^2+9
-
-::
-
-    sage: f = maxima('x^3 * %e^(k*x) * sin(w*x)'); f
-    x^3*%e^(k*x)*sin(w*x)
-    sage: f.diff('x')
-    k*x^3*%e^(k*x)*sin(w*x)+3*x^2*%e^(k*x)*sin(w*x)+w*x^3*%e^(k*x)*cos(w*x)
-    sage: f.integrate('x')
-    (((k*w^6+3*k^3*w^4+3*k^5*w^2+k^7)*x^3+(3*w^6+3*k^2*w^4-3*k^4*w^2-3*k^6)*x^2+(-18*k*w^4-12*k^3*w^2+6*k^5)*x-6*w^4+36*k^2*w^2-6*k^4)*%e^(k*x)*sin(w*x)+((-w^7-3*k^2*w^5-3*k^4*w^3-k^6*w)*x^3+(6*k*w^5+12*k^3*w^3+6*k^5*w)*x^2+(6*w^5-12*k^2*w^3-18*k^4*w)*x-24*k*w^3+24*k^3*w)*%e^(k*x)*cos(w*x))/(w^8+4*k^2*w^6+6*k^4*w^4+4*k^6*w^2+k^8)
-
-::
-
-    sage: f = maxima('1/x^2')
-    sage: f.integrate('x', 1, 'inf')
-    1
-    sage: g = maxima('f/sinh(k*x)^4')
-    sage: g.taylor('x', 0, 3)
-    f/(k^4*x^4)-2*f/(3*k^2*x^2)+11*f/45-62*k^2*f*x^2/945
-
-::
-
-    sage: maxima.taylor('asin(x)','x',0, 10)
-    x+x^3/6+3*x^5/40+5*x^7/112+35*x^9/1152
-
-Examples involving matrices
----------------------------
-
-We illustrate computing with the matrix whose `i,j` entry
-is `i/j`, for `i,j=1,\ldots,4`.
-
-::
-
-    sage: f = maxima.eval('f[i,j] := i/j')
-    sage: A = maxima('genmatrix(f,4,4)'); A
-    matrix([1,1/2,1/3,1/4],[2,1,2/3,1/2],[3,3/2,1,3/4],[4,2,4/3,1])
-    sage: A.determinant()
-    0
-    sage: A.echelon()
-    matrix([1,1/2,1/3,1/4],[0,0,0,0],[0,0,0,0],[0,0,0,0])
-    sage: A.eigenvalues()
-    [[0,4],[3,1]]
-    sage: A.eigenvectors()
-    [[[0,4],[3,1]],[[[1,0,0,-4],[0,1,0,-2],[0,0,1,-4/3]],[[1,2,3,4]]]]
-
-We can also compute the echelon form in Sage::
-
-    sage: B = matrix(QQ, A)
-    sage: B.echelon_form()
-    [  1 1/2 1/3 1/4]
-    [  0   0   0   0]
-    [  0   0   0   0]
-    [  0   0   0   0]
-    sage: B.charpoly('x').factor()
-    (x - 4) * x^3
-
-Laplace Transforms
-------------------
-
-We illustrate Laplace transforms::
-
-    sage: _ = maxima.eval("f(t) := t*sin(t)")
-    sage: maxima("laplace(f(t),t,s)")
-    2*s/(s^2+1)^2
-
-::
-
-    sage: maxima("laplace(delta(t-3),t,s)") #Dirac delta function
-    %e^-(3*s)
-
-::
-
-    sage: _ = maxima.eval("f(t) := exp(t)*sin(t)")
-    sage: maxima("laplace(f(t),t,s)")
-    1/(s^2-2*s+2)
-
-::
-
-    sage: _ = maxima.eval("f(t) := t^5*exp(t)*sin(t)")
-    sage: maxima("laplace(f(t),t,s)")
-    360*(2*s-2)/(s^2-2*s+2)^4-480*(2*s-2)^3/(s^2-2*s+2)^5+120*(2*s-2)^5/(s^2-2*s+2)^6
-    sage: print maxima("laplace(f(t),t,s)")
-                                             3                 5
-               360 (2 s - 2)    480 (2 s - 2)     120 (2 s - 2)
-              --------------- - --------------- + ---------------
-                2           4     2           5     2           6
-              (s  - 2 s + 2)    (s  - 2 s + 2)    (s  - 2 s + 2)
-
-::
-
-    sage: maxima("laplace(diff(x(t),t),t,s)")
-    s*'laplace(x(t),t,s)-x(0)
-
-::
-
-    sage: maxima("laplace(diff(x(t),t,2),t,s)")
-    -?%at('diff(x(t),t,1),t=0)+s^2*'laplace(x(t),t,s)-x(0)*s
-
-It is difficult to read some of these without the 2d
-representation::
-
-    sage: print maxima("laplace(diff(x(t),t,2),t,s)")
-                         !
-                d        !         2
-              - -- (x(t))!      + s  laplace(x(t), t, s) - x(0) s
-                dt       !
-                         !t = 0
-
-Even better, use
-``view(maxima("laplace(diff(x(t),t,2),t,s)"))`` to see
-a typeset version.
-
-Continued Fractions
--------------------
-
-A continued fraction `a + 1/(b + 1/(c + \cdots))` is
-represented in maxima by the list `[a, b, c, \ldots]`.
-
-::
-
-    sage: maxima("cf((1 + sqrt(5))/2)")
-    [1,1,1,1,2]
-    sage: maxima("cf ((1 + sqrt(341))/2)")
-    [9,1,2,1,2,1,17,1,2,1,2,1,17,1,2,1,2,1,17,2]
-
-Special examples
-----------------
-
-In this section we illustrate calculations that would be awkward to
-do (as far as I know) in non-symbolic computer algebra systems like
-MAGMA or GAP.
-
-We compute the gcd of `2x^{n+4} - x^{n+2}` and
-`4x^{n+1} + 3x^n` for arbitrary `n`.
-
-::
-
-    sage: f = maxima('2*x^(n+4) - x^(n+2)')
-    sage: g = maxima('4*x^(n+1) + 3*x^n')
-    sage: f.gcd(g)
-    x^n
-
-You can plot 3d graphs (via gnuplot)::
-
-    sage: maxima('plot3d(x^2-y^2, [x,-2,2], [y,-2,2], [grid,12,12])')  # not tested
-    [displays a 3 dimensional graph]
-
-You can formally evaluate sums (note the ``nusum``
-command)::
-
-    sage: S = maxima('nusum(exp(1+2*i/n),i,1,n)')
-    sage: print S
-                            2/n + 3                   2/n + 1
-                          %e                        %e
-                   ----------------------- - -----------------------
-                      1/n         1/n           1/n         1/n
-                   (%e    - 1) (%e    + 1)   (%e    - 1) (%e    + 1)
-
-We formally compute the limit as `n\to\infty` of
-`2S/n` as follows::
-
-    sage: T = S*maxima('2/n')
-    sage: T.tlimit('n','inf')
-    %e^3-%e
-
-Miscellaneous
--------------
-
-Obtaining digits of `\pi`::
-
-    sage: maxima.eval('fpprec : 100')
-    '100'
-    sage: maxima(pi).bfloat()
-    3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068b0
-
-Defining functions in maxima::
-
-    sage: maxima.eval('fun[a] := a^2')
-    'fun[a]:=a^2'
-    sage: maxima('fun[10]')
-    100
-
-Interactivity
--------------
-
-Unfortunately maxima doesn't seem to have a non-interactive mode,
-which is needed for the Sage interface. If any Sage call leads to
-maxima interactively answering questions, then the questions can't be
-answered and the maxima session may hang. See the discussion at
-http://www.ma.utexas.edu/pipermail/maxima/2005/011061.html for some
-ideas about how to fix this problem. An example that illustrates this
-problem is ``maxima.eval('integrate (exp(a*x), x, 0, inf)')``.
-
-Latex Output
-------------
-
-To TeX a maxima object do this::
-
-    sage: latex(maxima('sin(u) + sinh(v^2)'))
-    \sinh v^2+\sin u
-
-Here's another example::
-
-    sage: g = maxima('exp(3*%i*x)/(6*%i) + exp(%i*x)/(2*%i) + c')
-    sage: latex(g)
-    -{{i\,e^{3\,i\,x}}\over{6}}-{{i\,e^{i\,x}}\over{2}}+c
-
-Long Input
-----------
-
-The MAXIMA interface reads in even very long input (using files) in
-a robust manner, as long as you are creating a new object.
-
-.. note::
-
-   Using ``maxima.eval`` for long input is much less robust, and is
-   not recommended.
-
-::
-
-    sage: t = '"%s"'%10^10000   # ten thousand character string.
-    sage: a = maxima(t)
-
-TESTS: This working tests that a subtle bug has been fixed::
-
-    sage: f = maxima.function('x','gamma(x)')
-    sage: g = f(1/7)
-    sage: g
-    gamma(1/7)
-    sage: del f
-    sage: maxima(sin(x))
-    sin(x)
-
-This tests to make sure we handle the case where Maxima asks if an
-expression is positive or zero.
-
-::
-
-    sage: var('Ax,Bx,By')
-    (Ax, Bx, By)
-    sage: t = -Ax*sin(sqrt(Ax^2)/2)/(sqrt(Ax^2)*sqrt(By^2 + Bx^2))
-    sage: t.limit(Ax=0,dir='+')
-    0
-
-A long complicated input expression::
-
-    sage: maxima._eval_line('((((((((((0) + ((1) / ((n0) ^ (0)))) + ((1) / ((n1) ^ (1)))) + ((1) / ((n2) ^ (2)))) + ((1) / ((n3) ^ (3)))) + ((1) / ((n4) ^ (4)))) + ((1) / ((n5) ^ (5)))) + ((1) / ((n6) ^ (6)))) + ((1) / ((n7) ^ (7)))) + ((1) / ((n8) ^ (8)))) + ((1) / ((n9) ^ (9)));')
-    '1/n9^9+1/n8^8+1/n7^7+1/n6^6+1/n5^5+1/n4^4+1/n3^3+1/n2^2+1/n1+1'
 """
 
 #*****************************************************************************
@@ -447,39 +45,13 @@
 #                  http://www.gnu.org/licenses/
 #*****************************************************************************
 
-from __future__ import with_statement
+from sage.symbolic.ring import SR
 
-import os, re, sys, subprocess
-import pexpect
-cygwin = os.uname()[0][:6]=="CYGWIN"
+from sage.libs.ecl import *
 
-from expect import Expect, ExpectElement, FunctionElement, ExpectFunction, gc_disabled, AsciiArtString
-from pexpect import EOF
+from maxima_abstract import MaximaAbstract, MaximaAbstractFunction, MaximaAbstractElement, MaximaAbstractFunctionElement, MaximaAbstractElementFunction
 
-from random import randrange
-
-##import sage.rings.all
-import sage.rings.complex_number
-
-from sage.misc.misc import verbose, DOT_SAGE, SAGE_ROOT
-
-from sage.misc.multireplace import multiple_replace
-
-COMMANDS_CACHE = '%s/maxima_commandlist_cache.sobj'%DOT_SAGE
-
-import sage.server.support
-
-import maxima_abstract
-from maxima_abstract import MaximaFunctionElement, MaximaExpectFunction, MaximaFunction, maxima_console
-
-# The Maxima "apropos" command, e.g., apropos(det) gives a list
-# of all identifiers that begin in a certain way.  This could
-# maybe be useful somehow... (?)  Also maxima has a lot for getting
-# documentation from the system -- this could also be useful.
-
-####################################################################
-## We begin here by initializing maxima in library more
-from sage.libs.ecl import *
+## We begin here by initializing maxima in library mode
 ecl_eval("(setf *load-verbose* NIL)")
 ecl_eval("(require 'maxima)")
 ecl_eval("(in-package :maxima)")
@@ -497,35 +69,75 @@
 (defun retrieve (msg flag &aux (print? nil))
   (declare (special msg flag print?))
   (or (eq flag 'noprint) (setq print? t))
-  (error (concatenate 'string "Maxima asks:" (with-output-to-string (*standard-output*)
-      (terpri)
+  (error 
+      (concatenate 'string "Maxima asks: " 
+      (string-trim '(#\Newline) 
+      (with-output-to-string (*standard-output*)
       (cond ((not print?)
-	     (setq print? t)
-	     (princ *prompt-prefix*)
-	     (princ *prompt-suffix*))
-	    ((null msg)
-	     (princ *prompt-prefix*)
-	     (princ *prompt-suffix*))
-	    ((atom msg)
-	     (format t "~a~a~a" *prompt-prefix* msg *prompt-suffix*)
-	     (mterpri))
-	    ((eq flag t)
-	     (princ *prompt-prefix*)
-	     (mapc #'princ (cdr msg))
-	     (princ *prompt-suffix*)
-	     (mterpri))
-	    (t
-	     (princ *prompt-prefix*)
-	     (displa msg)
-	     (princ *prompt-suffix*)
-	     (mterpri)))))))
+             (setq print? t)
+             (princ *prompt-prefix*)
+             (princ *prompt-suffix*)
+             )
+            ((null msg)
+             (princ *prompt-prefix*)
+             (princ *prompt-suffix*)
+             )
+            ((atom msg)
+             (format t "~a~a~a" *prompt-prefix* msg *prompt-suffix*)
+             )
+            ((eq flag t)
+             (princ *prompt-prefix*)
+             (mapc #'princ (cdr msg))
+             (princ *prompt-suffix*)
+             )
+            (t
+             (princ *prompt-prefix*)
+             (displa msg)
+             (princ *prompt-suffix*)
+             )
+      ))))
+  )
+)
 """)
 
 ecl_eval('(defparameter *dev-null* (make-two-way-stream (make-concatenated-stream) (make-broadcast-stream)))')
 ecl_eval('(defun principal nil (error "Divergent Integral"))')
-
 ecl_eval("(setf $errormsg nil)")
 
+#ecl_eval(r"(defun tex-derivative (x l r) (tex (if $derivabbrev (tex-dabbrev x) (tex-d x '\partial)) l r lop rop ))")
+
+#ecl_eval('(defun ask-evod (x even-odd)(error "Maxima asks a question"))')
+#ecl_eval('(defun ask-integerp (x)(error "Maxima asks a question"))')
+#ecl_eval('(defun ask-declare (x property)(error "Maxima asks a question"))')
+#ecl_eval('(defun ask-prop (object property fun-or-number)(error "Maxima asks a question"))')
+#ecl_eval('(defun asksign01 (a)(error "Maxima asks a question"))')
+#ecl_eval('(defun asksign (x)(error "Maxima asks a question"))')
+#ecl_eval('(defun asksign1 ($askexp)(error "Maxima asks a question"))')
+#ecl_eval('(defun ask-greateq (x y)(error "Maxima asks a question"))')
+#ecl_eval('(defun askinver (a)(error "Maxima asks a question"))')
+#ecl_eval('(defun npask (exp)(error "Maxima asks a question"))')
+
+ecl_eval("(setf original-standard-output *standard-output*)")
+ecl_eval("(setf *standard-output* *dev-null*)")
+#ecl_eval("(setf *error-output* *dev-null*)")
+
+# display2d -- no ascii art output
+# keepfloat -- don't automatically convert floats to rationals
+init_code = ['display2d : false', 'domain : complex', 'keepfloat : true', 'load(to_poly_solver)', 'load(simplify_sum)']
+# Turn off the prompt labels, since computing them *very
+# dramatically* slows down the maxima interpret after a while.
+# See the function makelabel in suprv1.lisp.
+# Many thanks to andrej.vodopivec@gmail.com and also
+# Robert Dodier for figuring this out!
+# See trac # 6818.  
+init_code.append('nolabels : true')
+for l in init_code:
+    ecl_eval("#$%s$"%l)
+## To get more debug information uncomment the next line
+## should allow to do this through a method
+#ecl_eval("(setf *standard-output* original-standard-output)")
+
+# This returns an EclObject
 maxima_eval=ecl_eval("""
 (defun maxima-eval( form )
     (let ((result (catch 'macsyma-quit (cons 'maxima_eval (meval form)))))
@@ -554,25 +166,11 @@
 )
 """)
 
-#ecl_eval('(defun ask-evod (x even-odd)(error "Maxima asks a question"))')
-#ecl_eval('(defun ask-integerp (x)(error "Maxima asks a question"))')
-#ecl_eval('(defun ask-declare (x property)(error "Maxima asks a question"))')
-#ecl_eval('(defun ask-prop (object property fun-or-number)(error "Maxima asks a question"))')
-#ecl_eval('(defun asksign01 (a)(error "Maxima asks a question"))')
-#ecl_eval('(defun asksign (x)(error "Maxima asks a question"))')
-#ecl_eval('(defun asksign1 ($askexp)(error "Maxima asks a question"))')
-#ecl_eval('(defun ask-greateq (x y)(error "Maxima asks a question"))')
-#ecl_eval('(defun askinver (a)(error "Maxima asks a question"))')
-#ecl_eval('(defun npask (exp)(error "Maxima asks a question"))')
-
-
-import sage.symbolic.expression
-from sage.symbolic.ring import is_SymbolicVariable
-from sage.symbolic.ring import SR
-
 maxima_lib_instances = 0
 
-maxprint=EclObject("$STRING")
+# The Maxima string function can change the structure of its input
+#maxprint=EclObject("$STRING")
+maxprint=EclObject("(defun mstring-for-sage (form) (coerce (mstring form) 'string))").eval()
 meval=EclObject("MEVAL")
 msetq=EclObject("MSETQ")
 mlist=EclObject("MLIST")
@@ -590,174 +188,70 @@
 max_use_grobner=EclObject("$USE_GROBNER")
 max_to_poly_solve=EclObject("$TO_POLY_SOLVE")
 
+def stdout_to_string(s):
+    return ecl_eval("(with-output-to-string (*standard-output*) (maxima-eval #$%s$))"%s).python()[1:-1]
+
 def max_to_string(s):
-     return meval(EclObject([[maxprint],s])).python()[1:-1]
+     return maxprint(s).python()[1:-1]
 
-class Maxima(maxima_abstract.Maxima):
+my_mread=ecl_eval("""
+(defun my-mread (cmd)
+  (caddr (mread (make-string-input-stream cmd))))
+""")
+
+def parse_max_string(l):
+  return my_mread('"%s;"'%l)
+
+class MaximaLib(MaximaAbstract):
     """
-    Interface to the Maxima interpreter.
+    Interface to Maxima as a Library.
     """
-    def __init__(self, script_subdirectory=None, logfile=None, server=None,
-                 init_code = None):
+    def __init__(self):
         """
         Create an instance of the Maxima interpreter.
 
         TESTS::
-        
-            sage: maxima == loads(dumps(maxima))
+
+            sage: from sage.interfaces.maxima_lib import maxima_lib
+            sage: maxima_lib == loads(dumps(maxima_lib))
             True
 
         We make sure labels are turned off (see trac 6816)::
         
-            sage: 'nolabels:true' in maxima._Expect__init_code
+            sage: 'nolabels : true' in maxima_lib._MaximaLib__init_code
             True
         """
         global maxima_lib_instances
         if maxima_lib_instances > 0:
             raise RuntimeError, "Maxima interface in library mode can only be instantiated once"
         maxima_lib_instances += 1
-        
-        #the single one gets defined in the Expect interface
-        self._eval_using_file_cutoff = 10**9
-        #the double underscore one seems to by private to the Maxima interface
-        #this must have started as a typo by someone
-        self.__eval_using_file_cutoff = 10**9
-        self._available_vars = []
-        self._Expect__seq = 0
-        self._session_number = 1
-        self._Expect__name = "maxima"
 
-        if True:
-            # display2d -- no ascii art output
-            # keepfloat -- don't automatically convert floats to rationals
-            init_code = ['display2d : false', 'domain : complex', 'keepfloat : true', 'load(to_poly_solver)', 'load(simplify_sum)']
-            
-        # Turn off the prompt labels, since computing them *very
-        # dramatically* slows down the maxima interpret after a while.
-        # See the function makelabel in suprv1.lisp.
-        # Many thanks to andrej.vodopivec@gmail.com and also
-        # Robert Dodier for figuring this out!
-        # See trac # 6818.  
-        init_code.append('nolabels : true')
-        ecl_eval("(setf original-standard-output *standard-output*)")
-        ecl_eval("(setf *standard-output* *dev-null*)")
-        for l in init_code:
-            ecl_eval("#$%s$"%l)
-        ecl_eval("(setf *standard-output* original-standard-output)")
+        global init_code
+        self.__init_code = init_code
+
+        ## The name should definitely be changed to maxima_lib, however much more changes are then needed elsewhere
+        ## With maxima, more things are fine, but for example _maxima_init_ gets called in calculus.calculus and the classic interface gets initialized (not started, it is already initialized by default, so that is not really a big deal)
+        MaximaAbstract.__init__(self,"maxima_lib")
+        self.__seq = 0
  
     def _coerce_from_special_method(self, x):
         if isinstance(x, EclObject):
-            return MaximaElement(self,self._create(x))
+            return MaximaLibElement(self,self._create(x))
         else:
-            return maxima_abstract.Maxima._coerce_from_special_method(self,x)
-        
-        
-    def _function_class(self):
-        """
-        EXAMPLES::
-        
-            sage: maxima._function_class()
-            <class 'sage.interfaces.maxima_abstract.MaximaExpectFunction'>
-        """
-        return MaximaExpectFunction
-
-    def _start(self):
-        """
-        Starts the Maxima interpreter.
-        
-        EXAMPLES::
-        
-            sage: m = Maxima()
-            sage: m.is_running()
-            False
-            sage: m._start()
-            sage: m.is_running()
-            True
-        """
-#        ecl_eval(r"(defun tex-derivative (x l r) (tex (if $derivabbrev (tex-dabbrev x) (tex-d x '\partial)) l r lop rop ))")
-        pass
+            return MaximaAbstract._coerce_from_special_method(self,x)
         
     def __reduce__(self):
         """
         EXAMPLES::
         
-            sage: maxima.__reduce__()
-            (<function reduce_load_Maxima at 0x...>, ())
+            sage: from sage.interfaces.maxima_lib import maxima_lib
+            sage: maxima_lib.__reduce__()
+            (<function reduce_load_MaximaLib at 0x...>, ())
         """
-        return reduce_load_Maxima, tuple([])
+        return reduce_load_MaximaLib, tuple([])
 
-    def _sendline(self, str):
-        self._sendstr(str)
-        os.write(self._expect.child_fd, os.linesep)
-
-    def _expect_expr(self, expr=None, timeout=None):
-        """
-        EXAMPLES:
-            sage: a,b=var('a,b')
-            sage: integrate(1/(x^3 *(a+b*x)^(1/3)),x)
-            Traceback (most recent call last):
-            ...
-            RuntimeError: ECL says: Maxima asks:...
-            sage: assume(a>0)
-            sage: integrate(1/(x^3 *(a+b*x)^(1/3)),x)
-            2/9*sqrt(3)*b^2*arctan(1/3*(2*(b*x + a)^(1/3) + a^(1/3))*sqrt(3)/a^(1/3))/a^(7/3) + 2/9*b^2*log((b*x + a)^(1/3) - a^(1/3))/a^(7/3) - 1/9*b^2*log((b*x + a)^(2/3) + (b*x + a)^(1/3)*a^(1/3) + a^(2/3))/a^(7/3) + 1/6*(4*(b*x + a)^(5/3)*b^2 - 7*(b*x + a)^(2/3)*a*b^2)/((b*x + a)^2*a^2 - 2*(b*x + a)*a^3 + a^4)
-            sage: var('x, n')
-            (x, n)
-            sage: integral(x^n,x)
-            Traceback (most recent call last):
-            ...
-            RuntimeError: ECL says: Maxima asks:...
-            sage: assume(n+1>0)
-            sage: integral(x^n,x)
-            x^(n + 1)/(n + 1)
-            sage: forget()
-        """
-        if expr is None:
-            expr = self._prompt_wait
-        if self._expect is None:
-            self._start()
-        try:
-            if timeout:
-                i = self._expect.expect(expr,timeout=timeout)
-            else:
-                i = self._expect.expect(expr)
-            if i > 0:
-                v = self._expect.before
-
-                #We check to see if there is a "serious" error in Maxima.
-                #Note that this depends on the order of self._prompt_wait
-                if expr is self._prompt_wait and i > len(self._ask):
-                    self.quit()
-                    raise ValueError, "%s\nComputation failed due to a bug in Maxima -- NOTE: Maxima had to be restarted."%v
-
-                j = v.find('Is ')
-                v = v[j:]
-                k = v.find(' ',4)
-                msg = "Computation failed since Maxima requested additional constraints (try the command 'assume(" + v[4:k] +">0)' before integral or limit evaluation, for example):\n" + v + self._ask[i-1]
-                self._sendline(";")
-                self._expect_expr()
-                raise ValueError, msg
-        except KeyboardInterrupt, msg:
-            #print self._expect.before
-            i = 0
-            while True:
-                try:
-                    print "Control-C pressed.  Interrupting Maxima. Please wait a few seconds..."
-                    self._sendstr('quit;\n'+chr(3))
-                    self._sendstr('quit;\n'+chr(3))
-                    self.interrupt()
-                    self.interrupt()
-                except KeyboardInterrupt:
-                    i += 1
-                    if i > 10:
-                        break
-                    pass
-                else:
-                    break
-            raise KeyboardInterrupt, msg
-
-    def _eval_line(self, line, allow_use_file=False,
-                   wait_for_prompt=True, reformat=True, error_check=True):
+    # This outputs a string
+    def eval(self, line, locals=None, reformat=True, **kwds):
         result = ''
         while line:
             ind_dollar=line.find("$")
@@ -769,54 +263,16 @@
                 else:
                     statement = line[:ind_semi]
                     line = line[ind_semi+1:]
-                if statement: result = ((result + '\n') if result else '')+ max_to_string(maxima_eval("#$%s$"%statement))
+                if statement: result = ((result + '\n') if result else '') + max_to_string(maxima_eval("#$%s$"%statement))
             else:
                 statement = line[:ind_dollar]
                 line = line[ind_dollar+1:]
-                if statement: _ = max_to_string(maxima_eval("#$%s$"%statement))
-        return result
+                if statement: _ = maxima_eval("#$%s$"%statement)
+        if not reformat:
+            return result
+        return ''.join([x.strip() for x in result.split()])
 
-    def _synchronize(self):
-        """
-        Synchronize pexpect interface.
-        
-        This put a random integer (plus one!) into the output stream, then
-        waits for it, thus resynchronizing the stream. If the random
-        integer doesn't appear within 1 second, maxima is sent interrupt
-        signals.
-        
-        This way, even if you somehow left maxima in a busy state
-        computing, calling _synchronize gets everything fixed.
-        
-        EXAMPLES: This makes Maxima start a calculation::
-        
-            sage: maxima._sendstr('1/1'*500)
-        
-        When you type this command, this synchronize command is implicitly
-        called, and the above running calculation is interrupted::
-        
-            sage: maxima('2+2')
-            4
-        """
-        marker = '__SAGE_SYNCHRO_MARKER_'
-        if self._expect is None: return
-        r = randrange(2147483647)
-        s = marker + str(r+1)
-
-        # The 0; *is* necessary... it comes up in certain rare cases 
-        # that are revealed by extensive testing.  Don't delete it. -- william stein
-        cmd = '''0;sconcat("%s",(%s+1));\n'''%(marker,r)
-        self._sendstr(cmd)
-        try:
-            self._expect_expr(timeout=0.5)
-            if not s in self._before():
-                self._expect_expr(s,timeout=0.5)
-                self._expect_expr(timeout=0.5)
-        except pexpect.TIMEOUT, msg:
-            self._interrupt()
-        except pexpect.EOF:
-            self._crash_msg()
-            self.quit()
+    _eval_line = eval
 
     ###########################################
     # Direct access to underlying lisp interpreter. 
@@ -831,136 +287,11 @@
         
         EXAMPLES::
         
-            sage: maxima.lisp("(+ 2 17)")   # random formatted output
-             :lisp (+ 2 17)
-            19
-            (
+            sage: from sage.interfaces.maxima_lib import maxima_lib
+            sage: maxima_lib.lisp("(+ 2 17)")
+            <ECL: 19>
         """
-        self._eval_line(':lisp %s\n""'%cmd, allow_use_file=False, wait_for_prompt=False, reformat=False, error_check=False)
-        self._expect_expr('(%i)')
-        return self._before()
-
-    ###########################################
-    # Interactive help
-    ###########################################
-    def _command_runner(self, command, s, redirect=True):
-        """
-        Run ``command`` in a new Maxima session and return its
-        output as an ``AsciiArtString``.
-        
-        If redirect is set to False, then the output of the command is not
-        returned as a string. Instead, it behaves like os.system. This is
-        used for interactive things like Maxima's demos. See maxima.demo?
-        
-        EXAMPLES::
-        
-            sage: maxima._command_runner('describe', 'gcd')
-            -- Function: gcd (<p_1>, <p_2>, <x_1>, ...)
-            ...
-        """
-        cmd = 'maxima --very-quiet -r "%s(%s);" '%(command, s)
-        if sage.server.support.EMBEDDED_MODE:
-            cmd += '< /dev/null'
-
-        if redirect:
-            p = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE,
-                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
-            res = p.stdout.read()
-            # ecl-10.2 : 3 lines
-            # ecl-10.4 : 5 lines
-            # ecl-11.1 : 4 lines fancy a tango?
-            # We now get 4 lines of commented verbosity
-            # every time Maxima starts, so we need to get rid of them
-            for _ in range(4):
-                res = res[res.find('\n')+1:]
-            return AsciiArtString(res)
-        else:
-            subprocess.Popen(cmd, shell=True)
-
-    def _object_class(self):
-        """
-        Return the Python class of Maxima elements.
-        
-        EXAMPLES::
-        
-            sage: maxima._object_class()
-            <class 'sage.interfaces.maxima_abstract.MaximaElement'>
-        """
-        return MaximaElement
-
-    def _function_element_class(self):
-        """      
-        EXAMPLES::
-        
-            sage: maxima._function_element_class()
-            <class 'sage.interfaces.maxima_abstract.MaximaFunctionElement'>
-        """
-        return MaximaFunctionElement
-
-    def function(self, args, defn, rep=None, latex=None):
-        """
-        Return the Maxima function with given arguments and definition.
-        
-        INPUT:
-        
-        
-        -  ``args`` - a string with variable names separated by
-           commas
-        
-        -  ``defn`` - a string (or Maxima expression) that
-           defines a function of the arguments in Maxima.
-        
-        -  ``rep`` - an optional string; if given, this is how
-           the function will print.
-        
-        
-        EXAMPLES::
-        
-            sage: f = maxima.function('x', 'sin(x)')
-            sage: f(3.2)
-            -.058374143427580...
-            sage: f = maxima.function('x,y', 'sin(x)+cos(y)')
-            sage: f(2,3.5)
-            sin(2)-.9364566872907963
-            sage: f
-            sin(x)+cos(y)
-        
-        ::
-        
-            sage: g = f.integrate('z')
-            sage: g
-            (cos(y)+sin(x))*z
-            sage: g(1,2,3)
-            3*(cos(2)+sin(1))
-        
-        The function definition can be a maxima object::
-        
-            sage: an_expr = maxima('sin(x)*gamma(x)')
-            sage: t = maxima.function('x', an_expr)
-            sage: t
-            gamma(x)*sin(x)
-            sage: t(2)
-             sin(2)
-            sage: float(t(2))
-            0.90929742682568171
-            sage: loads(t.dumps())
-            gamma(x)*sin(x)
-        """
-        name = self._next_var_name()
-        if isinstance(defn, MaximaElement):
-            defn = defn.str()
-        elif not isinstance(defn, str):
-            defn = str(defn)
-        if isinstance(args, MaximaElement):
-            args = args.str()
-        elif not isinstance(args, str):
-            args = str(args)
-        cmd = '%s(%s) := %s'%(name, args, defn)
-        maxima._eval_line(cmd)
-        if rep is None:
-            rep = defn
-        f = MaximaFunction(self, name, rep, args, latex)
-        return f
+        return ecl_eval(cmd)
 
     def set(self, var, value):
         """
@@ -976,21 +307,15 @@
         
         EXAMPLES::
         
-            sage: maxima.set('xxxxx', '2')
-            sage: maxima.get('xxxxx')
+            sage: from sage.interfaces.maxima_lib import maxima_lib
+            sage: maxima_lib.set('xxxxx', '2')
+            sage: maxima_lib.get('xxxxx')
             '2'
         """
         if not isinstance(value, str):
             raise TypeError
         cmd = '%s : %s$'%(var, value.rstrip(';'))
-        if len(cmd) > self.__eval_using_file_cutoff:
-            self._batch(cmd, batchload=True)
-        else:
-            self._eval_line(cmd)
-            #self._sendline(cmd)
-            #self._expect_expr()
-            #out = self._before()
-            #self._error_check(cmd, out)
+        self.eval(cmd)
 
     def clear(self, var):
         """
@@ -998,17 +323,18 @@
 
         EXAMPLES::
 
-            sage: maxima.set('xxxxx', '2')
-            sage: maxima.get('xxxxx')
+            sage: from sage.interfaces.maxima_lib import maxima_lib
+            sage: maxima_lib.set('xxxxx', '2')
+            sage: maxima_lib.get('xxxxx')
             '2'
-            sage: maxima.clear('xxxxx')
-            sage: maxima.get('xxxxx')
+            sage: maxima_lib.clear('xxxxx')
+            sage: maxima_lib.get('xxxxx')
             'xxxxx'
         """
         try:
-            self._expect.send('kill(%s)$'%var)
+            self.eval('kill(%s)$'%var)
         except (TypeError, AttributeError):
-             pass
+            pass
 
     def get(self, var):
         """
@@ -1016,11 +342,12 @@
         
         EXAMPLES::
         
-            sage: maxima.set('xxxxx', '2')
-            sage: maxima.get('xxxxx')
+            sage: from sage.interfaces.maxima_lib import maxima_lib
+            sage: maxima_lib.set('xxxxx', '2')
+            sage: maxima_lib.get('xxxxx')
             '2'
         """
-        s = self._eval_line('%s;'%var)
+        s = self.eval('%s;'%var)
         return s
  
     def _create(self, value, name=None):
@@ -1030,21 +357,52 @@
         else:
             self.set(name, value)
         return name
-               
-    def version(self):
+
+    def _function_class(self):
         """
-        Return the version of Maxima that Sage includes.
+        EXAMPLES::
+        
+            sage: from sage.interfaces.maxima_lib import maxima_lib
+            sage: maxima_lib._function_class()
+            <class 'sage.interfaces.maxima_lib.MaximaLibFunction'>
+        """
+        return MaximaLibFunction
+
+    def _object_class(self):
+        """
+        Return the Python class of Maxima elements.
         
         EXAMPLES::
         
-            sage: maxima.version()
-            '5.23.2'
+            sage: from sage.interfaces.maxima_lib import maxima_lib
+            sage: maxima_lib._object_class()
+            <class 'sage.interfaces.maxima_lib.MaximaLibElement'>
         """
-        return maxima_version()
+        return MaximaLibElement
 
-##some helper functions to wrap tha calculus use of the maxima interface.
-##these routines expect arguments living in the symbolic ring and return something
-##that is hopefully coercible into the symbolic ring again.
+    def _function_element_class(self):
+        """      
+        EXAMPLES::
+        
+            sage: from sage.interfaces.maxima_lib import maxima_lib
+            sage: maxima_lib._function_element_class()
+            <class 'sage.interfaces.maxima_lib.MaximaLibFunctionElement'>
+        """
+        return MaximaLibFunctionElement
+
+    def _object_function_class(self):
+        """
+        EXAMPLES::
+        
+            sage: from sage.interfaces.maxima_lib import maxima_lib
+            sage: maxima_lib._object_function_class()
+            <class 'sage.interfaces.maxima_lib.MaximaLibElementFunction'>
+        """
+        return MaximaLibElementFunction
+
+    ##some helper functions to wrap the calculus use of the maxima interface.
+    ##these routines expect arguments living in the symbolic ring and return something
+    ##that is hopefully coercible into the symbolic ring again.
 
     def sr_integral(self,*args):
         try:
@@ -1082,29 +440,23 @@
             L.append(max_minus)
         return max_to_sr(maxima_eval(([max_tlimit],L)))
 
-##     def display2d(self, flag=True):
-##         """
-##         Set the flag that determines whether Maxima objects are
-##         printed using their 2-d ASCII art representation.  When the
-##         maxima interface starts the default is that objects are not
-##         represented in 2-d.
 
-##         INPUT:
-##             flag -- bool (default: True)
+def is_MaximaLibElement(x):
+    """
+    Returns True if x is of type MaximaLibElement.
+    
+    EXAMPLES::
+    
+        sage: from sage.interfaces.maxima_lib import maxima_lib, is_MaximaLibElement
+        sage: m = maxima_lib(1)
+        sage: is_MaximaLibElement(m)
+        True
+        sage: is_MaximaLibElement(1)
+        False
+    """
+    return isinstance(x, MaximaLibElement)
 
-##         EXAMPLES
-##             sage: maxima('1/2')
-##             1/2
-##             sage: maxima.display2d(True)
-##             sage: maxima('1/2')
-##                                            1
-##                                            -
-##                                            2
-##             sage: maxima.display2d(False)
-##         """
-##         self._display2d = bool(flag)
-
-class MaximaElement(maxima_abstract.MaximaElement):
+class MaximaLibElement(MaximaAbstractElement):
     """
     """    
     def ecl(self):
@@ -1122,58 +474,68 @@
             cmd=EclObject([[max_to_poly_solve], self.ecl(), sr_to_max(vars)])
         return self.parent()(maxima_eval(cmd))
 
-def is_MaximaElement(x):
-    """
-    Returns True if x is of type MaximaElement.
-    
-    EXAMPLES::
-    
-        sage: from sage.interfaces.maxima import is_MaximaElement
-        sage: m = maxima(1)
-        sage: is_MaximaElement(m)
-        True
-        sage: is_MaximaElement(1)
-        False
-    """
-    return isinstance(x, MaximaElement)
+    def display2d(self, onscreen=True):
+        """
+        EXAMPLES::
+        
+            sage: from sage.interfaces.maxima_lib import maxima_lib
+            sage: F = maxima_lib('x^5 - y^5').factor()  
+            sage: F.display2d ()              
+                                   4      3    2  2    3      4
+                       - (y - x) (y  + x y  + x  y  + x  y + x )
+        """
+        self._check_valid()
+        P = self.parent()
+        P._eval_line('display2d : true$')
+        s = stdout_to_string('disp(%s)'%self.name())
+        #s = P._eval_line('disp(%s)$'%self.name())
+        P._eval_line('display2d : false$')
+        s = s.strip('\r\n')
 
-# An instance
-maxima = Maxima()
+        # if ever want to dedent, see
+        # http://mail.python.org/pipermail/python-list/2006-December/420033.html
+        if onscreen:
+            print s
+        else:
+            return s
 
-def reduce_load_Maxima():
+
+class MaximaLibFunctionElement(MaximaAbstractFunctionElement):
+    pass
+
+
+class MaximaLibFunction(MaximaAbstractFunction):
+    pass
+
+
+class MaximaLibElementFunction(MaximaLibElement, MaximaAbstractElementFunction):
+    pass
+
+
+# The (unique) instance
+maxima_lib = MaximaLib()
+maxima = maxima_lib
+
+
+def reduce_load_MaximaLib():
     """
     EXAMPLES::
     
-        sage: from sage.interfaces.maxima import reduce_load_Maxima
-        sage: reduce_load_Maxima()
-        Maxima
+        sage: from sage.interfaces.maxima_lib import reduce_load_MaximaLib
+        sage: reduce_load_MaximaLib()
+        Maxima_lib
     """
-    return maxima
+    return maxima_lib
 
-
-def maxima_version():
-    """
-    EXAMPLES::
-    
-        sage: from sage.interfaces.maxima import maxima_version
-        sage: maxima_version()
-        '5.23.2'
-    """
-    return os.popen('maxima --version').read().split()[-1]
-
-def __doctest_cleanup():
-    import sage.interfaces.quit
-    sage.interfaces.quit.expect_quitall()
-
-
-import sage.symbolic.expression
-from sage.symbolic.ring import SR
+#**********************************
+# ???
 
 import sage.symbolic.expression
 import sage.functions.trig
 import sage.functions.log
 import sage.functions.other
 import sage.symbolic.integration.integral
+from sage.symbolic.operators import FDerivativeOperator
 
 car=EclObject("car")
 cdr=EclObject("cdr")
@@ -1187,8 +549,6 @@
 NIL=EclObject("NIL")
 ratdisrep=EclObject("ratdisrep")
 
-sage_op_dict={}
-
 sage_op_dict = {
     sage.symbolic.expression.operator.abs : "MABS",
     sage.symbolic.expression.operator.add : "MPLUS",
@@ -1223,10 +583,10 @@
     sage.functions.other.erf : "%ERF",
     sage.functions.other.gamma_inc : "%GAMMA_INCOMPLETE"
 }
-
 #we compile the dictionary
 sage_op_dict = dict([(k,EclObject(sage_op_dict[k])) for k in sage_op_dict])
 max_op_dict = dict([(sage_op_dict[k],k) for k in sage_op_dict])
+
 def add_vararg(*args):
     S=0
     for a in args:
@@ -1244,6 +604,7 @@
 
 mplus=EclObject("MPLUS")
 mtimes=EclObject("MTIMES")
+mdiff=EclObject("%DERIVATIVE")
 rat=EclObject("RAT")
 max_i=EclObject("$%I")
 max_op_dict[mplus]=add_vararg
@@ -1290,10 +651,14 @@
     else:
         return sage.symbolic.integration.integral.indefinite_integral(*args, hold=True)
 
+def mdiff_to_sage(expr):
+    return max_to_sr(expr.cadr()).diff(*[max_to_sr(e) for e in expr.cddr()])
+
 special_max_to_sage={
     EclObject("MRAT") : mrat_to_sage,
-    EclObject("MQAPPLY") : mqapply_to_sage,
-    EclObject("%INTEGRATE") : dummy_integrate
+    mqapply : mqapply_to_sage,
+    EclObject("%INTEGRATE") : dummy_integrate,
+    mdiff : mdiff_to_sage
 }
 
 special_sage_to_max={
@@ -1312,9 +677,9 @@
     elif isinstance(obj,sage.rings.number_field.number_field_element_quadratic.NumberFieldElement_quadratic) and obj.parent().defining_polynomial().list() == [1,0,1]:
         re, im = obj.list()
         return EclObject([[mplus], pyobject_to_max(re), [[mtimes], pyobject_to_max(im), max_i]])
-    
     return EclObject(obj)
 
+# This goes from SR to EclObject
 def sr_to_max(expr):
     r"""
     """
@@ -1324,10 +689,30 @@
         return EclObject(([mlist],[sr_to_max(e) for e in expr]))
     op = expr.operator()
     if op:
-        if (op in special_sage_to_max):
+        # Stolen from sage.symbolic.expression_conversion
+        # Should be defined in a function and then put in special_sage_to_max
+        # For that, we should change the API of the functions there (we need to have access to op, not only to expr.operands()
+        if isinstance(op, FDerivativeOperator):
+            from sage.symbolic.ring import is_SymbolicVariable
+            args = expr.operands()
+            if (not all(is_SymbolicVariable(v) for v in args) or
+                len(args) != len(set(args))):
+                raise NotImplementedError, "arguments must be distinct variables"
+            f = sr_to_max(op.function()(*args))
+            params = op.parameter_set()
+            deriv_max = []
+            [deriv_max.extend([sr_to_max(args[i]), EclObject(params.count(i))]) for i in set(params)]
+            l = [mdiff,f]
+            l.extend(deriv_max)
+            return EclObject(l)
+        elif (op in special_sage_to_max):
             return EclObject(special_sage_to_max[op](*[sr_to_max(o) for o in expr.operands()]))
         elif not (op in sage_op_dict):
-            op_max=caar(maxima(expr).ecl())
+            # Maxima does some simplifications automatically by default
+            # so calling maxima(expr) can change the structure of expr
+            #op_max=caar(maxima(expr).ecl())
+            # This should be safe if we treated all special operators above
+            op_max=maxima(op).ecl()
             sage_op_dict[op]=op_max
             max_op_dict[op_max]=op
         return EclObject(([sage_op_dict[op]],
@@ -1344,18 +729,20 @@
         except TypeError:
             return maxima(expr).ecl()
     
+# This goes from EclObject to SR
 def max_to_sr(expr):
     if expr.consp():
         op_max=caar(expr)
         if op_max in special_max_to_sage:
             return special_max_to_sage[op_max](expr)
         if not(op_max in max_op_dict):
+            # This could be unsafe if the conversion to SR chenges the structure of expr
             sage_expr=SR(maxima(expr))
             max_op_dict[op_max]=sage_expr.operator()
             sage_op_dict[sage_expr.operator()]=op_max
         op=max_op_dict[op_max]
         max_args=cdr(expr)
-        args=[ max_to_sr(a) for a in max_args]
+        args=[max_to_sr(a) for a in max_args]
         return op(*args)
     elif expr.symbolp():
         if not(expr in max_sym_dict):
diff -r df3ffca81588 -r e20fb42bdea9 sage/structure/sage_object.pyx
--- a/sage/structure/sage_object.pyx	Tue Feb 15 17:14:05 2011 +0100
+++ b/sage/structure/sage_object.pyx	Mon Feb 14 14:06:15 2011 +0100
@@ -519,7 +519,14 @@
         import sage.interfaces.maxima
         I = sage.interfaces.maxima.maxima
         return self._interface_init_(I)
+
+    def _maxima_lib_(self, G=None):
+        from sage.interfaces.maxima_lib import maxima_lib
+        return self._interface_(maxima_lib)
     
+    def _maxima_lib_init_(self):
+        return self._maxima_init_()
+
     def _magma_init_(self, magma):
         """
         Given a Magma interpreter M, return a string that evaluates in
diff -r df3ffca81588 -r e20fb42bdea9 sage/symbolic/expression.pyx
--- a/sage/symbolic/expression.pyx	Tue Feb 15 17:14:05 2011 +0100
+++ b/sage/symbolic/expression.pyx	Mon Feb 14 14:06:15 2011 +0100
@@ -444,6 +444,8 @@
             True
         """
         if session is None:
+            # This chooses the Maxima interface used by calculus
+            # Maybe not such a great idea because the "default" interface is another one
             from sage.calculus.calculus import maxima
             return super(Expression, self)._interface_(maxima)
         else:
diff -r df3ffca81588 -r e20fb42bdea9 sage/symbolic/integration/external.py
--- a/sage/symbolic/integration/external.py	Tue Feb 15 17:14:05 2011 +0100
+++ b/sage/symbolic/integration/external.py	Mon Feb 14 14:06:15 2011 +0100
@@ -26,7 +26,7 @@
                 raise ValueError, "Integral is divergent."
             else:
                 raise
-    return result
+    return result._sage_()
 
 def sympy_integrator(expression, v, a=None, b=None):
     """
diff -r df3ffca81588 -r e20fb42bdea9 sage/symbolic/integration/integral.py
--- a/sage/symbolic/integration/integral.py	Tue Feb 15 17:14:05 2011 +0100
+++ b/sage/symbolic/integration/integral.py	Mon Feb 14 14:06:15 2011 +0100
@@ -596,7 +596,6 @@
             raise ValueError, "Unknown algorithm: %s" % algorithm
         return integrator(expression, v, a, b)
 
-
     if a is None:
         return indefinite_integral(expression, v)
     else:
