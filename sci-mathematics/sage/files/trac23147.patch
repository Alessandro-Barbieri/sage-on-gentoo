diff --git a/sage/algebras/clifford_algebra.py b/sage/algebras/clifford_algebra.py
index a7983b7..eae3a35 100644
--- a/sage/algebras/clifford_algebra.py
+++ b/sage/algebras/clifford_algebra.py
@@ -15,8 +15,9 @@ AUTHORS:
 # (at your option) any later version.
 #                  http://www.gnu.org/licenses/
 #*****************************************************************************
+from six import iteritems
 
-from sage.misc import six
+from sage.misc.six import with_metaclass
 from sage.misc.cachefunc import cached_method
 from sage.structure.unique_representation import UniqueRepresentation
 from copy import copy
@@ -119,7 +120,7 @@ class CliffordAlgebraElement(CombinatorialFreeModule.Element):
                 # the dictionary describing the element
                 # ``e[i]`` * (the element described by the dictionary ``cur``)
                 # (where ``e[i]`` is the ``i``-th standard basis vector).
-                for mr,cr in six.iteritems(cur):
+                for mr,cr in iteritems(cur):
                     # Commute the factor as necessary until we are in order
                     pos = 0
                     for j in mr:
@@ -155,7 +156,7 @@ class CliffordAlgebraElement(CombinatorialFreeModule.Element):
                 cur = next
 
             # Add the distributed terms to the total
-            for index,coeff in six.iteritems(cur):
+            for index,coeff in iteritems(cur):
                 d[index] = d.get(index, zero) + cl * coeff
                 if d[index] == zero:
                     del d[index]
@@ -729,8 +730,8 @@ class CliffordAlgebra(CombinatorialFreeModule):
         if x in self.free_module():
             R = self.base_ring()
             if x.parent().base_ring() is R:
-                return self.element_class(self, {(i,): c for i,c in six.iteritems(x)})
-            return self.element_class(self, {(i,): R(c) for i,c in six.iteritems(x) if R(c) != R.zero()})
+                return self.element_class(self, {(i,): c for i,c in iteritems(x)})
+            return self.element_class(self, {(i,): R(c) for i,c in iteritems(x) if R(c) != R.zero()})
 
         if isinstance(x, CliffordAlgebraElement):
             if x.parent() is self:
@@ -1206,7 +1207,7 @@ class CliffordAlgebra(CombinatorialFreeModule):
                 for m,c in (Bi*Bj - Bj*Bi):
                     d[(a, K.index(m)+k*b)] = c
         m = Matrix(R, d, nrows=k, ncols=k*k, sparse=True)
-        from_vector = lambda x: self.sum_of_terms(((K[i], c) for i,c in six.iteritems(x)),
+        from_vector = lambda x: self.sum_of_terms(((K[i], c) for i,c in iteritems(x)),
                                                   distinct=True)
         return tuple(map( from_vector, m.kernel().basis() ))
 
@@ -1220,7 +1221,7 @@ class CliffordAlgebra(CombinatorialFreeModule):
         #         v = B[i]*B[j] - B[j]*B[i]
         #         eqns[a].extend([v[k] for k in K])
         # m = Matrix(R, eqns)
-        # from_vector = lambda x: self.sum_of_terms(((K[i], c) for i,c in six.iteritems(x)),
+        # from_vector = lambda x: self.sum_of_terms(((K[i], c) for i,c in iteritems(x)),
         #                                           distinct=True)
         # return tuple(map( from_vector, m.kernel().basis() ))
 
@@ -1303,7 +1304,7 @@ class CliffordAlgebra(CombinatorialFreeModule):
                 for m,c in supercommutator:
                     d[(a, K.index(m)+k*b)] = c
         m = Matrix(R, d, nrows=k, ncols=k*k, sparse=True)
-        from_vector = lambda x: self.sum_of_terms(((K[i], c) for i,c in six.iteritems(x)),
+        from_vector = lambda x: self.sum_of_terms(((K[i], c) for i,c in iteritems(x)),
                                                   distinct=True)
         return tuple(map( from_vector, m.kernel().basis() ))
 
@@ -1317,7 +1318,7 @@ class CliffordAlgebra(CombinatorialFreeModule):
         #         v = B[i].supercommutator(B[j])   # or better an if-loop as above
         #         eqns[a].extend([v[k] for k in K])
         # m = Matrix(R, eqns)
-        # from_vector = lambda x: self.sum_of_terms(((K[i], c) for i,c in six.iteritems(x)),
+        # from_vector = lambda x: self.sum_of_terms(((K[i], c) for i,c in iteritems(x)),
         #                                           distinct=True)
         # return tuple(map( from_vector, m.kernel().basis() ))
 
@@ -2160,7 +2161,7 @@ class ExteriorAlgebra(CliffordAlgebra):
 #####################################################################
 ## Differentials
 
-class ExteriorAlgebraDifferential(six.with_metaclass(
+class ExteriorAlgebraDifferential(with_metaclass(
         InheritComparisonClasscallMetaclass,
         ModuleMorphismByLinearity, UniqueRepresentation
     )):
@@ -2202,13 +2203,13 @@ class ExteriorAlgebraDifferential(six.with_metaclass(
         """
         d = {}
 
-        for k,v in six.iteritems(dict(s_coeff)):
+        for k,v in iteritems(dict(s_coeff)):
             if not v: # Strip terms with 0
                 continue
 
             if isinstance(v, dict):
                 R = E.base_ring()
-                v = E._from_dict({(i,): R(c) for i,c in six.iteritems(v)})
+                v = E._from_dict({(i,): R(c) for i,c in iteritems(v)})
             else:
                 # Make sure v is in ``E``
                 v = E(v)
@@ -2627,7 +2628,7 @@ class ExteriorAlgebraCoboundary(ExteriorAlgebraDifferential):
         self._cos_coeff = {}
         zero = E.zero()
         B = E.basis()
-        for k,v in six.iteritems(dict(s_coeff)):
+        for k, v in iteritems(dict(s_coeff)):
             k = B[k]
             for m,c in v:
                 self._cos_coeff[m] = self._cos_coeff.get(m, zero) + c * k
diff --git a/sage/algebras/commutative_dga.py b/sage/algebras/commutative_dga.py
index a44f14a..e571a51 100644
--- a/sage/algebras/commutative_dga.py
+++ b/sage/algebras/commutative_dga.py
@@ -71,9 +71,10 @@ AUTHORS:
 # (at your option) any later version.
 #                  http://www.gnu.org/licenses/
 #*****************************************************************************
-from __future__ import print_function
+from __future__ import print_function, absolute_import
+from six import string_types
 
-from sage.misc import six
+from sage.misc.six import with_metaclass
 from sage.structure.unique_representation import UniqueRepresentation
 from sage.structure.sage_object import SageObject
 from sage.misc.cachefunc import cached_method
@@ -98,7 +99,7 @@ from sage.rings.quotient_ring import QuotientRing_nc
 from sage.rings.quotient_ring_element import QuotientRingElement
 
 
-class Differential(six.with_metaclass(
+class Differential(with_metaclass(
         InheritComparisonClasscallMetaclass,
         UniqueRepresentation, Morphism
     )):
@@ -849,7 +850,7 @@ class GCAlgebra(UniqueRepresentation, QuotientRing_nc):
             else:
                 n = len(degrees)
             names = tuple('x{}'.format(i) for i in range(n))
-        elif isinstance(names, six.string_types):
+        elif isinstance(names, string_types):
             names = tuple(names.split(','))
             n = len(names)
         else:
diff --git a/sage/misc/converting_dict.py b/sage/misc/converting_dict.py
index 2902e2f..7833847 100644
--- a/sage/misc/converting_dict.py
+++ b/sage/misc/converting_dict.py
@@ -46,6 +46,7 @@ result no matter how a generator is identified::
 # (at your option) any later version.
 #                  http://www.gnu.org/licenses/
 #*****************************************************************************
+from __future__ import absolute_import
 from six import iteritems
 
 import collections
diff --git a/sage/misc/dev_tools.py b/sage/misc/dev_tools.py
index 34b8500..9274984 100644
--- a/sage/misc/dev_tools.py
+++ b/sage/misc/dev_tools.py
@@ -14,7 +14,7 @@ AUTHORS:
 #                  http://www.gnu.org/licenses/
 #******************************************************************************
 from __future__ import absolute_import
-from six import iteritems
+from six import iteritems, string_types
 
 
 def runsnake(command):
@@ -519,10 +519,10 @@ def import_statements(*objects, **kwds):
         name = None    # the name of the object
 
         # 1. if obj is a string, we look for an object that has that name
-        if isinstance(obj, str):
+        if isinstance(obj, string_types):
             name = obj
             obj = find_objects_from_name(name, 'sage')
-            if len(obj) == 0:
+            if not obj:
                 obj = find_objects_from_name(name)
 
             # remove lazy imported objects from list obj
diff --git a/sage/misc/inline_fortran.py b/sage/misc/inline_fortran.py
index 2701a6f..faf115d 100644
--- a/sage/misc/inline_fortran.py
+++ b/sage/misc/inline_fortran.py
@@ -1,7 +1,9 @@
 """
 Fortran compiler
 """
+from __future__ import absolute_import
 from six import iteritems
+
 import os
 import imp
 import shutil
diff --git a/sage/misc/mathml.py b/sage/misc/mathml.py
index aa987c4..d584a48 100644
--- a/sage/misc/mathml.py
+++ b/sage/misc/mathml.py
@@ -22,6 +22,7 @@ method _mathml_(self) that returns its MathML representation.
 #
 #                  http://www.gnu.org/licenses/
 #*****************************************************************************
+from __future__ import absolute_import
 from six import iteritems, integer_types
 
 
diff --git a/sage/misc/nested_class_test.py b/sage/misc/nested_class_test.py
index a60bf68..8bba13b 100644
--- a/sage/misc/nested_class_test.py
+++ b/sage/misc/nested_class_test.py
@@ -44,7 +44,7 @@ alternative is to use ClasscallMetaclass as metaclass::
 #  Distributed under the terms of the GNU General Public License (GPL)
 #                  http://www.gnu.org/licenses/
 #******************************************************************************
-from __future__ import print_function
+from __future__ import print_function, absolute_import
 from six import add_metaclass
 
 __all__ = [] # Don't document any parents
diff --git a/sage/misc/sagedoc.py b/sage/misc/sagedoc.py
index e2593b1..ebe1015 100644
--- a/sage/misc/sagedoc.py
+++ b/sage/misc/sagedoc.py
@@ -41,6 +41,8 @@ Check that sphinx is not imported at Sage start-up::
 
 from __future__ import print_function
 from __future__ import absolute_import
+from six import string_types
+
 import os, re, sys
 import pydoc
 from sage.misc.temporary_file import tmp_dir
@@ -635,7 +637,7 @@ def format(s, embedded=False):
         ...
 
     """
-    if not isinstance(s, str):
+    if not isinstance(s, string_types):
         raise TypeError("s must be a string")
 
     # Leading empty lines must be removed, since we search for directives
@@ -717,7 +719,7 @@ def format_src(s):
         sage: format_src('<<<Sq>>>')[5:15]
         'Sq(*nums):'
     """
-    if not isinstance(s, str):
+    if not isinstance(s, string_types):
         raise TypeError("s must be a string")
     docs = set([])
     import sage.all
diff --git a/sage/misc/sageinspect.py b/sage/misc/sageinspect.py
index 91254e1..18b54c9 100644
--- a/sage/misc/sageinspect.py
+++ b/sage/misc/sageinspect.py
@@ -114,7 +114,8 @@ defined Cython code, and with rather tricky argument lines::
 """
 from __future__ import print_function, absolute_import
 from six.moves import range
-from six import iteritems, string_types, class_types
+from six import iteritems, string_types, class_types, text_type
+from sage.misc.six import u
 
 import ast
 import inspect
@@ -354,9 +355,9 @@ def _extract_source(lines, lineno):
         raise ValueError("Line numbering starts at 1! (tried to extract line {})".format(lineno))
     lineno -= 1
 
-    if isinstance(lines, str):
+    if isinstance(lines, string_types):
         lines = lines.splitlines(True) # true keeps the '\n'
-    if len(lines) > 0:
+    if len(lines):
         # Fixes an issue with getblock
         lines[-1] += '\n'
 
@@ -1635,7 +1636,7 @@ def _sage_getdoc_unformatted(obj):
     # not a 'getset_descriptor' or similar.
     if not isinstance(r, string_types):
         return ''
-    elif isinstance(r, unicode):
+    elif isinstance(r, text_type):  # unicode (py2) = str (py3)
         return r.encode('utf-8', 'ignore')
     else:
         return r
@@ -2115,7 +2116,11 @@ def sage_getsourcelines(obj):
     pos = _extract_embedded_position(d)
     if pos is None:
         try:
+            # BEWARE HERE
+            # inspect gives str (=bytes) in python2
+            # and str (=unicode) in python3
             return inspect.getsourcelines(obj)
+
         except (IOError, TypeError) as err:
             try:
                 objinit = obj.__init__
diff --git a/sage/misc/six.py b/sage/misc/six.py
index 37295c7..92ea494 100644
--- a/sage/misc/six.py
+++ b/sage/misc/six.py
@@ -108,6 +108,18 @@ def u(x):
     r"""
     Convert `x` to unicode, assuming UTF-8 encoding.
 
+    Python2 behaviour:
+
+    If input is unicode, returns the input.
+
+    If input is str (assumed to be utf-8 encoded), convert to unicode.
+
+    Python3 behaviour:
+
+    If input is str, returns the input.
+
+    If input is bytes (assumed to be utf-8 encoded), convert to unicode.
+
     EXAMPLES::
 
         sage: from sage.misc.six import u
@@ -116,6 +128,8 @@ def u(x):
         sage: u(u"500 \u20ac")
         u'500 \u20ac'
     """
-    if isinstance(x, unicode):
+    if isinstance(x, text_type):  # py2 unicode and py3 str
         return x
-    return str(x).decode("utf-8")
+    if isinstance(x, bytes):
+        return x.decode("utf-8")
+    raise TypeError('input has no conversion to unicode')
diff --git a/sage/misc/superseded.py b/sage/misc/superseded.py
index 7cb1c22..2628bde 100644
--- a/sage/misc/superseded.py
+++ b/sage/misc/superseded.py
@@ -22,7 +22,7 @@ Functions and classes
 #
 #                  http://www.gnu.org/licenses/
 ########################################################################
-from __future__ import print_function
+from __future__ import print_function, absolute_import
 from six import iteritems
 
 from warnings import warn
