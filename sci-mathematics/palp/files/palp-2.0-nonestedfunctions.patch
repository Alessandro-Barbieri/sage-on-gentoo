--- MoriCone.c	2011-06-23 02:59:04.000000000 +1200
+++ MoriCone.c.new	2012-03-06 12:29:22.718499527 +1300
@@ -592,9 +592,6 @@
   int *nmt,int *nt)			// P,p,F[c],X,CT[nmf],&nmt[nmf],nt[nmf]
 { int d=P->n,v=d+2,i,j,k=0,r,F[POLY_Dmax+2],Z[POLY_Dmax+2],z=0, // GKZ polygon:
     R[VERT_Nmax][POLY_Dmax],nrp[VERT_Nmax],nr,neg=0,tnt=0;// num.max.tri
-  void AddInsertR(int S,int K){int J,L;if(K){for(J=nr++;J>S;J--)// aux proc.:
-      {nrp[J]=nrp[J-1];for(L=0;L<nrp[J];L++)R[J][L]=R[J-1][L];} // add/insert
-      R[S][0]=i;nrp[S]=1;} else R[S][nrp[S]++]=i;}		// i -> rays R
   Matrix A,B; Init_Matrix(&A,v,d); Inci64 U;		 // P.x::F[A]::F[Z[R]]
   for(i=0;i<p;i++) if(getN(i,FI)){for(j=0;j<d;j++) A.x[k][j]=P->x[i][j];
     F[k++]=i;} assert(k==d+2); GaleTransform(A,&B); U=0;	// F_i<d+2
@@ -605,13 +602,26 @@
   nr=1; nrp[0]=1; R[0][0]=0;		// Z[z]::T[0] {circuits} in F[]::=facet
   for(i=1;i<z;i++) if(0<=(k=BZangle(i,0))){	// points with positive angle
     if(k==0) r=0; // else if(nr==1) r=1; // insert@ 0 < r <=nr; add@ 0 <= r <nr
-    else for(r=1;r<nr;r++) if((k=BZangle(i,*R[r]))<=0) break; 
-    AddInsertR(r,k);    }	// if(k) insert at r; else add to R[r];
+    else for(r=1;r<nr;r++) if((k=BZangle(i,*R[r]))<=0) break;
+    {
+    	int J,L;
+    	if(k){for(J=nr++;J>r;J--)
+    	{nrp[J]=nrp[J-1];for(L=0;L<nrp[J];L++)R[J][L]=R[J-1][L];}
+    	R[r][0]=i;nrp[r]=1;} else R[r][nrp[r]++]=i;
+    }// if(k) insert at r; else add to R[r];
+  }
+
   for(i=1;i<z;i++) if(0>(k=BZangle(i,0))){ 	// points with negative angle
     if(neg==0) {r=neg=nr; k=1;}  	// init neg.
     else for(r=neg;r<nr;r++) if((k=BZangle(i,*R[r]))<=0) break; 
 //printf("i=%d: neg=%d nr=%d  ->  k=%d r=%d\n",i,neg,nr,k,r);
-    AddInsertR(r,k);}				 		CT[*nmt=0]=X;
+    {
+        int J,L;
+        if(k){for(J=nr++;J>r;J--)
+        {nrp[J]=nrp[J-1];for(L=0;L<nrp[J];L++)R[J][L]=R[J-1][L];}
+        R[r][0]=i;nrp[r]=1;} else R[r][nrp[r]++]=i;
+        }// if(k) insert at r; else add to R[r];
+  }				 		CT[*nmt=0]=X;
 #if (TRACE_TRIANGULATION)
 	printf("U="); prnI(p,U); printf(" -> rays: ");
 	for(r=0;r<nr;r++){printf("R[%d]=",r);			
@@ -665,10 +675,10 @@
   int Tli[VERT_Nmax][3],Eli[VERT_Nmax][2],IEli[VERT_Nmax][9],ien[VERT_Nmax];
   int tn=0,en=0, a,b,c, k,l,iem=0,ies=0,nQuad=0,chi=0,ncr=0;
   
-  int ChamberTriangle(Long *Q,int *T){Long a,b,c;   // Q in BZR(T_0,T_1,T_2)
+/*  int ChamberTriangle(Long *Q,int *T){Long a,b,c;   // Q in BZR(T_0,T_1,T_2)
     if(0<=(a=XYZproduct(BZR(T[0]),BZR(T[1]),Q))) if(0<=(b=XYZproduct(BZR(T[1])
       ,BZR(T[2]),Q))) if(0<=(c=XYZproduct(BZR(T[2]),BZR(T[0]),Q)))
-    {assert(a*b*c>0); return 1;} return 0;}		 // END of DECLARATIONS
+    {assert(a*b*c>0); return 1;} return 0;}		 // END of DECLARATIONS */
 
   Init_Matrix(&A,Inci64_abs(FI),d);for(i=0;i<=p;i++)if(getN(i,FI)){	// GALE
     for(j=0;j<d;j++) A.x[f][j]=P->x[i][j]; F[f++]=i;} 	GaleTransform(A,&B);
@@ -899,10 +909,16 @@
 
   CT[*nmt=0]=X; // CT[#][list] -> X, *nmt=#MaxTri nt[num]=#Triang
   for(i=0;i<ncr;i++){Inci64 *S=CT[*nmt], U=0;	// TRIANGulate forall chambers
-    Long *Q=CR[i]; nt[*nmt]=0; for(j=0;j<tn;j++) if(ChamberTriangle(Q,Tli[j])){
-      for(a=0;a<nrp[Tli[j][0]];a++)for(b=0;b<nrp[Tli[j][1]];b++)for(c=0;c<
+    Long *Q=CR[i]; nt[*nmt]=0; for(j=0;j<tn;j++)
+    {Long a,b,c; int ChamberTriangle = 0;
+    	if(0<=(a=XYZproduct(BZR(Tli[j][0]),BZR(Tli[j][1]),Q)))
+    		if(0<=(b=XYZproduct(BZR(Tli[j][1]),BZR(Tli[j][2]),Q)))
+    			if(0<=(c=XYZproduct(BZR(Tli[j][2]),BZR(Tli[j][0]),Q)))
+    			{assert(a*b*c>0); ChamberTriangle = 1;}
+    	if(ChamberTriangle){
+    		for(a=0;a<nrp[Tli[j][0]];a++)for(b=0;b<nrp[Tli[j][1]];b++)for(c=0;c<
 	nrp[Tli[j][2]];c++){S[nt[*nmt]]=C-makeN(F[Z[R[Tli[j][0]][a]]])-makeN(F[
-	Z[R[Tli[j][1]][b]]])-makeN(F[Z[R[Tli[j][2]][c]]]);U|=S[nt[*nmt]++];}}
+	Z[R[Tli[j][1]][b]]])-makeN(F[Z[R[Tli[j][2]][c]]]);U|=S[nt[*nmt]++];}}}
     if(U==C) {CT[*nmt+1]=&CT[*nmt][nt[*nmt]]; tmt+=nt[(*nmt)++];}
 #ifdef	PRINT_NON_MAXIMAL_TRIANGULATIONS
 	j=(*nmt)-(U==C);if(U==C)printf("maximal[");else printf("non-max[");
--- Polynf.c	2011-06-23 02:59:04.000000000 +1200
+++ Polynf.c.new	2012-03-06 12:29:40.143515045 +1300
@@ -2383,6 +2383,8 @@
 }
 
 
+#if(0)
+
 #define	TESTfano		 0
 #define	FanoProjNPmax		14
 #define FPcirNmax		15
@@ -2959,3 +2961,5 @@
   /*printf("\n SCHLUSS (von 1 Zelle): nf=%d\n",nf);*/
   return nf;/* nf = number of output polytopes (just for statistics) */
 }	   
+
+#endif
