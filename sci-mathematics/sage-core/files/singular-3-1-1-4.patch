# HG changeset patch
# User Martin Albrecht <malb@informatik.uni-bremen.de>
# Date 1267795375 0
# Node ID e72bba40789546e1a6fb717567a680241a2e29b8
# Parent  96e2020790df6a5f4d413e65b111f0ec6e73fc2a
adapted to new Singular 3-1-0-9 API

diff -r 96e2020790df -r e72bba407895 sage/interfaces/singular.py
--- a/sage/interfaces/singular.py	Mon Jun 28 23:27:14 2010 +0100
+++ b/sage/interfaces/singular.py	Fri Mar 05 13:22:55 2010 +0000
@@ -9,7 +9,7 @@
   singular(...), x.[tab] includes all singular commands.
 
 - Martin Albrecht (2006-03-06): This patch adds the equality symbol to
-  singular. Also fix problem in which" " as prompt means comparison
+
   will break all further communication with Singular.
 
 - Martin Albrecht (2006-03-13): added current_ring() and
@@ -1769,8 +1769,8 @@
         
             sage: R = singular.ring(0, '(x,y,z)', 'dp')
             sage: A = singular.matrix(2,2)
-            sage: A.nrows._sage_doc_()
-            "\nnrows\n-----\n\n`*Syntax:*'\n ...
+            sage: 'matrix_expression' in A.nrows._sage_doc_()
+            True
         """
         if not nodes:
             generate_docstring_dictionary()
@@ -1829,7 +1829,7 @@
     singular_docdir = os.environ["SAGE_LOCAL"]+"/share/singular/"
 
     new_node = re.compile("File: singular\.hlp,  Node: ([^,]*),.*")
-    new_lookup = re.compile("\* ([^:]*):*([^.]*)\.")
+    new_lookup = re.compile("\* ([^:]*):*([^.]*)\..*")
 
     L, in_node, curr_node = [], False, None
 
@@ -1849,7 +1849,7 @@
                a,b = m.groups()
                node_names[a] = b.strip()
 
-        if line == "Index\n":
+        if line == "6 Index\n":
             in_node = False
 
     nodes[curr_node] = "".join(L) # last node
diff -r 96e2020790df -r e72bba407895 sage/libs/singular/function.pyx
--- a/sage/libs/singular/function.pyx	Mon Jun 28 23:27:14 2010 +0100
+++ b/sage/libs/singular/function.pyx	Fri Mar 05 13:22:55 2010 +0000
@@ -1205,7 +1205,7 @@
         self.call_handler = self.get_call_handler()
 
     cdef BaseCallHandler get_call_handler(self):
-        cdef idhdl* singular_idhdl = ggetid(self._name, 0)
+        cdef idhdl* singular_idhdl = ggetid(self._name)
         if singular_idhdl==NULL:
             raise NameError("Function '%s' is not defined."%self._name)
         if singular_idhdl.typ!=PROC_CMD:
@@ -1216,7 +1216,7 @@
         return res
 
     cdef bint function_exists(self):
-        cdef idhdl* singular_idhdl = ggetid(self._name, 0)
+        cdef idhdl* singular_idhdl = ggetid(self._name)
         return singular_idhdl!=NULL
 
 cdef class SingularKernelFunction(SingularFunction):
diff -r 96e2020790df -r e72bba407895 sage/libs/singular/option.pyx
--- a/sage/libs/singular/option.pyx	Mon Jun 28 23:27:14 2010 +0100
+++ b/sage/libs/singular/option.pyx	Fri Mar 05 13:22:55 2010 +0000
@@ -93,7 +93,7 @@
 from sage.libs.singular.decl cimport OPT_WEIGHTM, Sy_bit
 
 from sage.libs.singular.decl cimport V_SHOW_MEM, V_YACC, V_REDEFINE, V_READING, V_LOAD_LIB, V_DEBUG_LIB
-from sage.libs.singular.decl cimport V_LOAD_PROC, V_DEF_RES, V_DEBUG_MEM, V_SHOW_USE, V_IMAP, V_PROMPT
+from sage.libs.singular.decl cimport V_LOAD_PROC, V_DEF_RES, V_SHOW_USE, V_IMAP, V_PROMPT
 from sage.libs.singular.decl cimport V_NSB, V_CONTENTSB, V_CANCELUNIT, V_DEG_STOP
 
 
@@ -314,7 +314,6 @@
      - ``debugLib`` -
      - ``loadProc`` -
      - ``defRes`` -
-     - ``debugMem`` -
      - ``usage`` -
      - ``Imap`` -
      - ``prompt`` -
@@ -350,7 +349,6 @@
                          "debugLib": Sy_bit(V_DEBUG_LIB), 
                          "loadProc": Sy_bit(V_LOAD_PROC), 
                          "defRes":   Sy_bit(V_DEF_RES),   
-                         "debugMem": Sy_bit(V_DEBUG_MEM), 
                          "usage":    Sy_bit(V_SHOW_USE),  
                          "Imap":     Sy_bit(V_IMAP),      
                          "prompt":   Sy_bit(V_PROMPT),    
diff -r 96e2020790df -r e72bba407895 sage/libs/singular/singular-cdefs.pxi
--- a/sage/libs/singular/singular-cdefs.pxi	Mon Jun 28 23:27:14 2010 +0100
+++ b/sage/libs/singular/singular-cdefs.pxi	Fri Mar 05 13:22:55 2010 +0000
@@ -75,7 +75,6 @@
     cdef int V_DEBUG_LIB
     cdef int V_LOAD_PROC
     cdef int V_DEF_RES  
-    cdef int V_DEBUG_MEM
     cdef int V_SHOW_USE
     cdef int V_IMAP    
     cdef int V_PROMPT  
@@ -115,6 +114,8 @@
         napoly *n
         int s
 
+    ctypedef struct ring "ip_sring"
+
     ctypedef struct n_Procs_s:
 
         number* nDiv(number *, number *)
@@ -127,7 +128,7 @@
         number*  (*nPar)(int i)
         int     (*nParDeg)(number* n)
         int     (*nSize)(number* n)
-        int     (*nInt)(number* n)
+        int     (*n_Int)(number* n, ring *)
         int     (*nDivComp)(number* a,number* b)
         number*  (*nGetUnit)(number* a)
         number*  (*nExtGcd)(number* a, number* b, number* *s, number* *t)
@@ -212,7 +213,7 @@
 
     # ideals
 
-    ctypedef struct ideal "ip_sideal":
+    ctypedef struct ideal "sip_sideal":
         poly **m # gens array
         long rank # rank of module, 1 for ideals
         int nrows # always 1
@@ -679,7 +680,7 @@
 
     # return int representation of number n
     
-    int nInt(number *n)
+    int n_Int(number *n, ring *r)
 
     # general number division
     
@@ -727,7 +728,7 @@
 
     # get numerator
     
-    number *nlGetNom(number *n, ring *r)
+    number *nlGetNumerator(number *n, ring *r)
 
     # get denominator
     
@@ -759,7 +760,7 @@
 
     # algebraic number from int
     
-    number *naInit(int)
+    number *naInit(int, ring *r)
 
     # algebraic number destructor
     
@@ -779,11 +780,7 @@
 
     # get exponent of i-th variable
     
-    int napGetExp(napoly *, int i)
-
-    # loop through algebraic number
-    
-    napoly *napIter(napoly *)
+    int napGetExpFrom(napoly *, int i, ring* r)
 
     # normalize a number
 
@@ -802,7 +799,7 @@
 
 
     # init integer
-    number *nrzInit(int i)
+    number *nrzInit(int i, ring *r)
 
     # init ZmodN from GMP
     number *nrnMapGMP(number *v)
@@ -945,7 +942,6 @@
     cdef int V_DEBUG_LIB
     cdef int V_LOAD_PROC
     cdef int V_DEF_RES
-    cdef int V_DEBUG_MEM
     cdef int V_SHOW_USE
     cdef int V_IMAP
     cdef int V_PROMPT
@@ -962,7 +958,7 @@
 
     int     IsCmd(char *n, int  tok)
 
-    idhdl* ggetid(char *n, bint local)
+    idhdl* ggetid(char *n)
 
     leftv * iiMake_proc(idhdl *pn, package *pack, leftv *sl)
     
diff -r 96e2020790df -r e72bba407895 sage/libs/singular/singular.pyx
--- a/sage/libs/singular/singular.pyx	Mon Jun 28 23:27:14 2010 +0100
+++ b/sage/libs/singular/singular.pyx	Fri Mar 05 13:22:55 2010 +0000
@@ -29,12 +29,12 @@
 from sage.libs.singular.decl cimport SR_HDL, SR_INT, SR_TO_INT, singular_options
 from sage.libs.singular.decl cimport On, Off, SW_USE_NTL, SW_USE_NTL_GCD_0, SW_USE_EZGCD, SW_USE_NTL_SORT, SW_USE_NTL_GCD_P
 from sage.libs.singular.decl cimport napoly, lnumber, Sy_bit, OPT_REDSB, OPT_INTSTRATEGY, OPT_REDTAIL, OPT_REDTHROUGH
-from sage.libs.singular.decl cimport nlGetNom, nlGetDenom, nlDelete, nlInit2gmp
+from sage.libs.singular.decl cimport nlGetNumerator, nlGetDenom, nlDelete, nlInit2gmp
 from sage.libs.singular.decl cimport naIsOne, naIsOne, naIsZero, naPar, naInit, naAdd, naMult, naDelete, naMap00
-from sage.libs.singular.decl cimport napGetCoeff, napGetExp, napIter
+from sage.libs.singular.decl cimport napGetCoeff, napGetExpFrom, pNext
 from sage.libs.singular.decl cimport nrzInit, nr2mMapZp, nrnMapGMP
 from sage.libs.singular.decl cimport siInit
-from sage.libs.singular.decl cimport nInt, n_Init
+from sage.libs.singular.decl cimport n_Int, n_Init
 from sage.libs.singular.decl cimport rChangeCurrRing
 
 from sage.rings.rational_field import RationalField
@@ -79,11 +79,11 @@
     ##  structures aligned on 4 byte boundaries and therefor have last bit  zero.
     ##  (The second bit is reserved as tag to allow extensions of  this  scheme.)
     ##  Using immediates as pointers and dereferencing them gives address errors.
-    nom = nlGetNom(n, _ring)
+    nom = nlGetNumerator(n, _ring)
     mpz_init(nom_z)
 
     if (SR_HDL(nom) & SR_INT): mpz_set_si(nom_z, SR_TO_INT(nom))
-    else: mpz_set(nom_z,&nom.z)
+    else: mpz_set(nom_z,nom.z)
 
     mpq_set_num(_z,nom_z)
     nlDelete(&nom,_ring)
@@ -93,7 +93,7 @@
     mpz_init(denom_z)
 
     if (SR_HDL(denom) & SR_INT): mpz_set_si(denom_z, SR_TO_INT(denom))
-    else: mpz_set(denom_z,&denom.z)
+    else: mpz_set(denom_z,denom.z)
 
     mpq_set_den(_z, denom_z)
     nlDelete(&denom,_ring)
@@ -154,13 +154,13 @@
 
     while z:
         c = cache.objectptr.initi(c,<long>napGetCoeff(z))
-        e = napGetExp(z,1)
+        e = napGetExpFrom(z,1, _ring)
         if e == 0:
             ret = cache.objectptr.add(ret, c, ret)
         else:
             a = ( e * cache.objectptr.sage_generator() ) % order
             ret = cache.objectptr.axpy(ret, c, a, ret)
-        z = napIter(z)
+        z = <napoly*>pNext(<poly*>z)
     return (<FFgivE>cache._zero_element)._new_c(ret)
 
 cdef FFgf2eE si2sa_GFqNTLGF2E(number *n, ring *_ring, FiniteField_ntl_gf2e base):
@@ -191,9 +191,9 @@
 
     while z:
         c = <long>napGetCoeff(z)
-        e = napGetExp(z,1)
+        e = napGetExpFrom(z,1, _ring)
         ret += c * a**e
-        z = napIter(z)
+        z = <napoly*>pNext(<poly*>z)
     return ret
 
 cdef object si2sa_GFqPari(number *n, ring *_ring, object base):
@@ -224,12 +224,12 @@
 
     while z:
         c = <long>napGetCoeff(z)
-        e = napGetExp(z,1)
+        e = napGetExpFrom(z,1, _ring)
         if e == 0:
             ret = ret + c
         elif c != 0:
             ret = ret  + c * a**e 
-        z = napIter(z)
+        z = <napoly*>pNext(<poly*>z)
     return base(ret)
 
 cdef object si2sa_NF(number *n, ring *_ring, object base):
@@ -262,12 +262,12 @@
     while z:
         c = napGetCoeff(z)
         coeff = si2sa_QQ(c, _ring)
-        e = napGetExp(z,1)
+        e = napGetExpFrom(z,1, _ring)
         if e == 0:
             ret = ret + coeff
         elif coeff != 0:
             ret = ret  + coeff * a**e 
-        z = napIter(z)
+        z = <napoly*>pNext(<poly*>z)
     return base(ret)
 
 cdef inline object si2sa_ZZmod(number *n, ring *_ring, object base):
@@ -314,7 +314,7 @@
         ret.set_from_mpz(<__mpz_struct*>n)
         return base(ret)
 
-    return base(_ring.cf.nInt(n))
+    return base(_ring.cf.n_Int(n,_ring))
 
 cdef number *sa2si_QQ(Rational r, ring *_ring):
     """
@@ -343,11 +343,11 @@
 
     a = naPar(1)
 
-    apow1 = naInit(1)
-    n1 = naInit(0)
+    apow1 = naInit(1, _ring)
+    n1 = naInit(0, _ring)
 
     while quo!=0:
-        coeff = naInit(quo%b)
+        coeff = naInit(quo%b, _ring)
 
         if not naIsZero(coeff):
             n2 = naAdd( naMult(coeff, apow1),  n1)
@@ -376,12 +376,12 @@
     cdef GF2X_c rep = GF2E_rep(elem.x)
 
     if GF2X_deg(rep) >= 1:
-        n1 = naInit(0)
+        n1 = naInit(0, _ring)
         a = naPar(1)
-        apow1 = naInit(1)
+        apow1 = naInit(1, _ring)
 
         for i from 0 <= i <= GF2X_deg(rep):
-            coeff = naInit(GF2_conv_to_long(GF2X_coeff(rep,i)))
+            coeff = naInit(GF2_conv_to_long(GF2X_coeff(rep,i)), _ring)
 
             if not naIsZero(coeff):
                 n2 = naAdd( naMult(coeff, apow1),  n1)
@@ -397,7 +397,7 @@
         naDelete(&apow1, _ring)
         naDelete(&a, _ring)
     else:
-       n1 = naInit(GF2_conv_to_long(GF2X_coeff(rep,0)))
+       n1 = naInit(GF2_conv_to_long(GF2X_coeff(rep,0)), _ring)
 
     return n1
 
@@ -413,12 +413,12 @@
 
 
     if len(elem) > 1:
-        n1 = naInit(0)
+        n1 = naInit(0, _ring)
         a = naPar(1)
-        apow1 = naInit(1)
+        apow1 = naInit(1, _ring)
 
         for i from 0 <= i < len(elem):
-            coeff = naInit(int(elem[i]))
+            coeff = naInit(int(elem[i]), _ring)
 
             if not naIsZero(coeff):
                 n2 = naAdd( naMult(coeff, apow1),  n1)
@@ -434,7 +434,7 @@
         naDelete(&apow1, _ring)
         naDelete(&a, _ring)
     else:
-        n1 = naInit(int(elem))
+        n1 = naInit(int(elem), _ring)
 
     return n1
 
@@ -448,9 +448,9 @@
 
     elem = list(elem)
 
-    n1 = naInit(0)
+    n1 = naInit(0, _ring)
     a = naPar(1)
-    apow1 = naInit(1)
+    apow1 = naInit(1, _ring)
 
     for i from 0 <= i < len(elem):
         nlCoeff = nlInit2gmp( mpq_numref((<Rational>elem[i]).value), mpq_denref((<Rational>elem[i]).value) )
@@ -486,7 +486,7 @@
         sage: P(12345678901234567890) + 2 - 2
         12345678901234567890
     """
-    cdef number *n = nrzInit(0)
+    cdef number *n = nrzInit(0, _ring)
     mpz_set(<__mpz_struct*>n, d.value)
     return <number*>n
 
@@ -536,7 +536,7 @@
 
 cdef object si2sa(number *n, ring *_ring, object base):
     if PY_TYPE_CHECK(base, FiniteField_prime_modn):
-        return base(nInt(n))
+        return base(n_Int(n, _ring))
 
     elif PY_TYPE_CHECK(base, RationalField):
         return si2sa_QQ(n,_ring)
@@ -558,7 +558,7 @@
 
     elif PY_TYPE_CHECK(base, IntegerModRing_generic):
         if _ring.ringtype == 0:
-            return base(nInt(n))
+            return base(n_Int(n, _ring))
         return si2sa_ZZmod(n, _ring, base)
 
     else:
diff -r 96e2020790df -r e72bba407895 sage/rings/polynomial/multi_polynomial_libsingular.pyx
--- a/sage/rings/polynomial/multi_polynomial_libsingular.pyx	Mon Jun 28 23:27:14 2010 +0100
+++ b/sage/rings/polynomial/multi_polynomial_libsingular.pyx	Fri Mar 05 13:22:55 2010 +0000
@@ -3609,7 +3609,6 @@
 
         delete(iv)
         id_Delete(&I,_ring)
-        p_Delete(&ptemp,_ring)
         
         return F
 
@@ -3923,8 +3922,8 @@
         gcd = singclap_gcd(p_Copy(self._poly, _ring), p_Copy(_g._poly, _ring))
         prod = pp_Mult_qq(self._poly, _g._poly, _ring)
         ret = singclap_pdivide(prod , gcd )
-        p_Delete(&prod, _ring)
-        p_Delete(&gcd, _ring)
+        p_Delete(&prod, _ring) 
+        p_Delete(&gcd, _ring) 
         if count >= 20:
             _sig_off
         return new_MP(self._parent, ret)
@@ -4333,7 +4332,7 @@
         cdef int count = singular_polynomial_length_bounded(self._poly,20)+singular_polynomial_length_bounded(other._poly,20)
         if count >= 20:
             _sig_on
-        rt =  singclap_resultant(self._poly, other._poly, (<MPolynomial_libsingular>variable)._poly )
+        rt =  singclap_resultant(self._poly, other._poly,(<MPolynomial_libsingular>variable)._poly )
         if count >= 20:
             _sig_off
         return new_MP(self._parent, rt)
diff -r 96e2020790df -r e72bba407895 sage/rings/polynomial/toy_buchberger.py
--- a/sage/rings/polynomial/toy_buchberger.py	Mon Jun 28 23:27:14 2010 +0100
+++ b/sage/rings/polynomial/toy_buchberger.py	Fri Mar 05 13:22:55 2010 +0000
@@ -426,8 +426,8 @@
     Q = set(Q)
     while True:
         Qbar = set(Q)
-        for p in Qbar:
-            p = Q.pop()
+        for p in sorted(Qbar):
+            Q.remove(p)
             h = p.reduce(Q)
             if h!=0:
                 Q.add(h)
diff -r 96e2020790df -r e72bba407895 sage/rings/polynomial/toy_d_basis.py
--- a/sage/rings/polynomial/toy_d_basis.py	Mon Jun 28 23:27:14 2010 +0100
+++ b/sage/rings/polynomial/toy_d_basis.py	Fri Mar 05 13:22:55 2010 +0000
@@ -280,11 +280,11 @@
         sage: G = [f, fx, fy]
         sage: B = set(filter(lambda (x,y): x!=y, [(f1,f2) for f1 in G for f2 in G]))
         sage: select(B)
-        (3*x^2 + 7, x^3 - y^2 + 7*x - y + 1)
+        (-2*y - 1, 3*x^2 + 7)
     """
     min_d = 2**20
     min_pair = 0,0
-    for fi,fj in P:
+    for fi,fj in sorted(P):
         d = fi.parent().monomial_lcm(fi.lm(),fj.lm()).total_degree()
         if d < min_d:
             min_d = d
