--- cl.c.orig	2010-01-22 07:49:27.000000000 +0000
+++ cl.c	2009-06-14 09:31:12.000000000 +0000
@@ -40,6 +40,133 @@
 static int clique_list_size=0;
 
 
+// As the global variables remain between two SAGE call, they 
+// have to be reset each time
+void sage_reset_global_variables(){
+  find_all=FALSE;
+  min_weight=0;
+  min_weight_set=FALSE;
+  max_weight=0;
+  max_weight_set=FALSE;
+  maximal=FALSE;
+  unweighted=FALSE;
+  number1=TRUE;
+  quiet=0;
+  only_weight=FALSE;
+  clique_count=0;
+  clique_list_size=0;
+}
+
+
+// The opt structure has to be initialised in each SAGE function
+clique_options * sage_init_clique_opt(){
+  sage_reset_global_variables();
+  clique_options *opts;
+  quiet++;
+  opts=malloc(sizeof(clique_options));
+  if (quiet)
+    opts->time_function=NULL;
+  else
+    opts->time_function=clique_print_time;
+  opts->output=stderr;
+  opts->reorder_function=reorder;
+  opts->reorder_map=NULL;
+  // Without commenting these lines the sage_all_clique_max
+  // function does not work correctly
+
+  /*
+  if (quiet)
+    opts->user_function=print_clique_func;
+  else
+  */
+  opts->user_function=record_clique_func;
+  opts->user_data=NULL;
+  opts->clique_list=NULL;
+  opts->clique_list_length=0;
+  return opts;
+}
+
+
+// Computes a maximum clique of the graph g and return its size
+// The table list contains the ID of the vertices
+int sage_clique_max(graph_t *g,int **list){
+  sage_reset_global_variables();
+  quiet++;
+  find_all=FALSE;
+  maximal=TRUE;
+  number1=FALSE;
+  set_t s;
+  int i,l;
+  s=clique_unweighted_find_single(g,min_weight,
+				  max_weight,maximal,
+				  sage_init_clique_opt());
+
+  // Writing the answer into a int [] to be read by Sage
+  int size=set_size(s);
+  *list=malloc(sizeof(int)*size);
+  l=0;
+  for (i=0; i<SET_MAX_SIZE(s); i++) {
+    if (SET_CONTAINS(s,i)) {
+      *((*list)+l)=i;
+      l++;
+    }
+  }
+  return size;
+}
+
+
+
+int sage_all_clique_max(graph_t *g,int **list){
+  sage_reset_global_variables();
+  /*
+			find_all=TRUE;
+			find_all=FALSE;
+			only_weight=TRUE;
+			maximal=TRUE;
+
+			quiet++;
+  */
+  //  graph_print(g);
+  quiet++;
+  find_all=TRUE;
+  maximal=TRUE;
+  number1=FALSE;
+  int i,j,l;
+
+  clique_unweighted_find_all(g,min_weight,max_weight,
+			     maximal,sage_init_clique_opt());
+
+  int size=set_size(clique_list[0]);
+  *list=malloc(sizeof(int)*(size+1)*clique_count);
+  l=0;
+
+  for (j=0; j<clique_count; j++) {
+    for (i=0; i<SET_MAX_SIZE(clique_list[j]); i++) {
+      if (SET_CONTAINS(clique_list[j],i)) {
+        *((*list)+l)=i;
+        l++;
+      }
+    }
+    *((*list)+l)=-1;
+    l++;
+  }
+  return (1+size)*clique_count;
+}
+
+
+int sage_clique_number(graph_t *g){
+  sage_reset_global_variables();
+  find_all=FALSE;
+  only_weight=TRUE;
+  maximal=TRUE;
+  number1=FALSE;
+  clique_options *opts;
+  opts=sage_init_clique_opt();
+  return clique_unweighted_max_weight(g,opts);
+}
+
+
+
 int main(int argc, char **argv) {
 	FILE *fp;
 	graph_t *g;
--- /dev/null	2010-02-12 17:09:05.251004778 +0000
+++ cl.h	2009-07-07 13:01:34.000000000 +0000
@@ -0,0 +1,33 @@
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#ifdef ENABLE_LONG_OPTIONS
+#include <getopt.h>
+#endif
+
+#include "cliquer.h"
+
+
+#define TRYFORHELP  "Try `%s -h' for more information.\n",argv[0]
+
+void printhelp(char *prog);
+void read_options(int argc, char **argv);
+void print_search(graph_t *g);
+boolean record_clique_func(set_t s,graph_t *g,clique_options *opts);
+boolean print_clique_func(set_t s,graph_t *g,clique_options *opts);
+void print_clique(set_t s,graph_t *g);
+
+// As the global variables remain between two SAGE call, they 
+// have to be reset each time
+void sage_reset_global_variables();
+// The opt structure has to be initialised in each SAGE function
+clique_options * sage_init_clique_opt();
+// Computes a maximum clique of the graph g and return its size
+// The table list contains the ID of the vertices
+int sage_clique_max(graph_t *g,int **list);
+int sage_all_clique_max(graph_t *g,int **list);
+int sage_clique_number(graph_t *g);
+
+
